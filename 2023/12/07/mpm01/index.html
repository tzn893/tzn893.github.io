<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>物质质点法--从理论到实现 | tzn的小窝</title><meta name="author" content="tzn"><meta name="copyright" content="tzn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Push Forward and Pull Back对于一个双射映射，能找到$\forall  x \in \Omega^0$ 我们都有$\exists X\in \Omega^t$ 有$\Phi(X,t)&#x3D;x, \Phi^{-1}(x,t)&#x3D;X$ 对于任意映射$G:\Omega^0 \to R$ 我们都能定义$g:\Omega^t\to R$ ,$g(x,t)&#x3D;G(\Phi^{-1}(x,t))">
<meta property="og:type" content="article">
<meta property="og:title" content="物质质点法--从理论到实现">
<meta property="og:url" content="http://example.com/2023/12/07/mpm01/index.html">
<meta property="og:site_name" content="tzn的小窝">
<meta property="og:description" content="Push Forward and Pull Back对于一个双射映射，能找到$\forall  x \in \Omega^0$ 我们都有$\exists X\in \Omega^t$ 有$\Phi(X,t)&#x3D;x, \Phi^{-1}(x,t)&#x3D;X$ 对于任意映射$G:\Omega^0 \to R$ 我们都能定义$g:\Omega^t\to R$ ,$g(x,t)&#x3D;G(\Phi^{-1}(x,t))">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/16801.png">
<meta property="article:published_time" content="2023-12-06T16:44:02.000Z">
<meta property="article:modified_time" content="2023-12-06T17:00:00.449Z">
<meta property="article:author" content="tzn">
<meta property="article:tag" content="physics">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/16801.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/12/07/mpm01/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '物质质点法--从理论到实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-07 01:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/ranran0.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/16801.png')"><nav id="nav"><span id="blog-info"><a href="/" title="tzn的小窝"><span class="site-name">tzn的小窝</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">物质质点法--从理论到实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-06T16:44:02.000Z" title="发表于 2023-12-07 00:44:02">2023-12-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-06T17:00:00.449Z" title="更新于 2023-12-07 01:00:00">2023-12-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="物质质点法--从理论到实现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="Push-Forward-and-Pull-Back"><a href="#Push-Forward-and-Pull-Back" class="headerlink" title="Push Forward and Pull Back"></a>Push Forward and Pull Back</h4><p>对于一个双射映射，能找到$\forall  x \in \Omega^0$ 我们都有$\exists X\in \Omega^t$ 有$\Phi(X,t)=x, \Phi^{-1}(x,t)=X$</p>
<p>对于任意映射$G:\Omega^0 \to R$ 我们都能定义$g:\Omega^t\to R$ ,$g(x,t)=G(\Phi^{-1}(x,t)),G(X)=g(\Phi(X,t))$</p>
<h4 id="欧拉视角和拉格朗日视角"><a href="#欧拉视角和拉格朗日视角" class="headerlink" title="欧拉视角和拉格朗日视角"></a>欧拉视角和拉格朗日视角</h4><p>在拉格朗日视角下，系统的速度和加速度可以定义为:</p>
<script type="math/tex; mode=display">
V(X,t)= \frac{\partial \Phi}{\partial t}(X,t) \\
A(X,t)=\frac{\partial V}{\partial t}(X,t) (1)</script><p>而欧拉视角为拉格朗日视角的push forward:</p>
<script type="math/tex; mode=display">
v(x,t)=V(\Phi^{-1}(x,t),t),V(X,t),v(\Phi(X,t),t) = V(X,t)\\
a(x,t)=A(\Phi^{-1}(x,t),t),A(X,t),a(\Phi(X,t),t)=A(X,t) (2)</script><p>将(2)带入(1)中可得:</p>
<script type="math/tex; mode=display">
a(x,t)=\frac{\partial v}{\partial t} (\Phi(X,t),t)=\frac{\partial v}{\partial t}(x,t)+\frac{\partial v}{\partial x}(x,t) \cdot \frac{\partial \Phi}{\partial t}(X,t)=\frac{\partial v}{\partial t} (x,t) + \frac{\partial v}{\partial x}(x,t) \cdot v(x,t)</script><p>令$\frac{D}{Dt} v(\Phi(X,t),t)=\frac{\partial v}{\partial t} (x,t) + \frac{\partial v}{\partial x}(x,t) \cdot v(x,t)$ 为$v$ 的材料导数，则对$a$ 有</p>
<script type="math/tex; mode=display">
a(x,t)= \frac{D}{Dt} v</script><p>对于更一般的函数$f$ ，材料导数有:</p>
<script type="math/tex; mode=display">
\frac{D}{D t}f=\frac{\partial f}{\partial t} (x,t) + \frac{\partial f}{\partial x} (x,t) \cdot v(x,t)</script><p>若f为形变梯度F（$F=\frac{\partial \Phi}{\partial X}(X,t)$）的push forward,由于$\frac{D}{Dt} f$ 为$\frac{\partial }{\partial t} F$ 的pull back，且:</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial t} F(X,t)= \frac{\partial }{\partial t} \frac{\partial \Phi}{\partial X}(X,t)=\frac{\partial V}{\partial X}(X,t)=\frac{\partial v}{\partial \Phi}(\Phi(X,t),t)\frac{\partial \Phi}{\partial X}(X,t)=\frac{\partial v}{\partial \Phi}(\phi(X,t),t) F (2.1)</script><p>则:</p>
<script type="math/tex; mode=display">
\frac{D}{Dt} f=\frac{\partial v}{\partial \Phi}(\phi(X,t),t) F=\frac{\partial v}{\partial x}(x,t) f (3)</script><h4 id="积分变换"><a href="#积分变换" class="headerlink" title="积分变换"></a>积分变换</h4><p>对于线微元$dl_1,dl_2,dl_3$ 以及三个单位正交方向$e_1,e_2,e_3$ ,体微分可以表示为$dV=dl_1 e_1 \cdot(dl_2e_2 \times dl_3 e_3)= dl_1dl_2dl_3$</p>
<p>对该微元施加任意形变$F$ 后有$\mathbf{ dl_i’}=F \mathbf{dl_i}$</p>
<p>则该体微分变为($F_1,F_2,F_3$为矩阵$F$的1,2,3列)</p>
<script type="math/tex; mode=display">
dV'= dl_1Fe_1\cdot (dl_2Fe_2\times dl_3Fe_3)=dl_1dl_2dl_3\cdot F_1\cdot (F_2 \times F_3)=det(F) dl_1dl_2dl_3</script><p>对于形变后的区域和形变前的区域$B^t,B^0$ 存在变换:</p>
<script type="math/tex; mode=display">
\int _{B^t} g(x,t)|_tdx=\int_{B^0}G(\Phi^{-1}(x,t)) det(F) dX=\int_{B^0} G(X) det(F) dX (4)</script><p>其中$G$ 为$g$ 的pull back</p>
<p>对于法线方向为$N$ 的面微元$d\mathbf{S}$ 以及push forward后法线为$n$的面微元$d\mathbf{s}$ 。以及一个任意线微元$d\mathbf{L}$ 以及其push forward $d\mathbf{l}$ (注意：法线N到n的变换不满足$FN=n$的关系！):</p>
<script type="math/tex; mode=display">
dV = d\mathbf{S} \cdot d \mathbf{L}\\
dv=d\mathbf{s}\cdot d\mathbf{l}\\</script><p>令$det(F)=J$根据$dV$ 和$dv$ 的关系:</p>
<script type="math/tex; mode=display">
dv=JdV=Jd\mathbf{S} \cdot dL=d\mathbf{s}\cdot d\mathbf{l}=d\mathbf{s} \cdot Fd\mathbf{L}\\
Jd\mathbf{S}^TdL=d\mathbf{s}^TFdL\\
d\mathbf{s}=F^{-T}Jd\mathbf{S}</script><p>则定义在$\partial B^t$ 上的面积分$h(x,t)$以及其push forward$H(X)$ 可以表示为:</p>
<script type="math/tex; mode=display">
\int_{\partial B^t} h(x,t)|_t d\mathbf{s}=\int _{\partial B^0} H(X) F^{-T}Jd\mathbf{S} (5)</script><h4 id="压力场"><a href="#压力场" class="headerlink" title="压力场"></a>压力场</h4><p>压力可以定义为一个在$\Omega^t\to R^{d\times d}$ 的一个场。 Piola-Kirchoff压力场可以被定义为:</p>
<script type="math/tex; mode=display">
P=\frac{\partial \psi}{\partial F}</script><p> 其中$\psi:\Omega^t \to R$ 为形变能量密度函数。</p>
<p>柯西压力场的定义可以从该定义中衍生(柯西压力为Piola-Kirchoff由$B^0\to B^{t^n}$ 的push forward)：</p>
<script type="math/tex; mode=display">
\sigma =\frac{1}{det(F)} P F^T=\frac{1}{det(F)} \frac{\partial \psi}{\partial F} F^T (6)</script><p>由于在刚性变化下（$x=R(t)X+p(t),F=R$)，我们期望其压力为0。因此 我们令</p>
<script type="math/tex; mode=display">
\psi(F)=\psi(F^TF)</script><p>在刚体变换中$F^TF=R^TR=I, \psi(F)=\psi(I)$ 为常量。而$F^TF=C$ 一般被称为Cauchy-Green张量。</p>
<p>在图形中，一般常常把$\psi(F^TF)$ 写为:$\psi(\Sigma(F))$</p>
<p>其中$\Sigma(F)$ 为$F=U\Sigma V^T$ 中$F$对应的奇异值矩阵$\Sigma$</p>
<p>TODO: $F$的快速奇异值分解</p>
<p>一种常用的模型为Neo-Hookean模型，该模型的形式为:</p>
<script type="math/tex; mode=display">
\psi(F)=\frac{\mu}{2}(tr(F^TF)-d)-\mu ln(J)+\frac{\lambda}{2}ln^2J (7)</script><p>其Piola-Kirchoff可被定义为</p>
<script type="math/tex; mode=display">
P=\mu(F-F^{-T})+\lambda ln(J) F^{-T} (8)</script><p>另一种常用的模型fixed corotated model为:</p>
<script type="math/tex; mode=display">
\psi(F)=\psi(\Sigma(F))=\mu \sum_{i=1}^a (\sigma_i-1)^2+\frac{\lambda}{2}(J-1)^2 (9)</script><p>其Piola-Kirchoff张量可以被定义为</p>
<p>TODO:计算$\frac{\partial \psi(F)}{\partial F}$ </p>
<script type="math/tex; mode=display">
P(F)=\frac{\partial \psi(F)}{\partial F} = 2\mu(F-R) + \lambda(J-1)JF^{-T} (10)</script><p>其中$F=RS=UV^TV\Sigma V^T\to R=UV^T, S=V\Sigma V^T$</p>
<p>TODO:计算$\frac{\partial^2 \psi(F)}{\partial F^2}$ </p>
<h4 id="塑性形变"><a href="#塑性形变" class="headerlink" title="塑性形变"></a>塑性形变</h4><p>对于形变梯度$F$ 可以将其分解为弹性形变$F_E$ 和塑性形变$F_P$ </p>
<script type="math/tex; mode=display">
F=F_{E}F_{P}</script><p> 在计算压力过程中，只有$F_{E}$ 部分会对计算结果有影响，而$F_{P}$ 不会参与计算。也就是说，$F_{P}$施加的影响会永久施加到物体上。</p>
<p><img src="/images/phy1/mpm4.png" alt=""></p>
<p>对于雪的塑性形变的模拟，一种常见的方式是将$F_{E}$ 的特奇异值限制在$[1-\theta_c,1+\theta_s]$ 的范围内。</p>
<p>对于模拟的第$n$ 步状态$F^n=F_E^nF^n_S$ ,首先假设在$F^{n+1}$时没发生任何塑性形变</p>
<script type="math/tex; mode=display">
F^{n+1}=\hat{F}^{n+1}_EF_P^n</script><p>在$F^{n+1}$ 以及$F^n_P$ 已知时，可求出对应情况下的$\hat{F}_{E}^{n+1}$</p>
<script type="math/tex; mode=display">
\hat{F}_E^{n+1}=F^{n+1}(F_P^n)^{-1}</script><p>接着我们通过奇异值分解，将$\hat{F}_{E}^{n+1}=U^{n+1} (\hat{\Sigma}^{n+1}) (V^{n+1})^T$ 的奇异值限制在$[1-\theta_c,1+\theta_s] $  的范围内，并通过$F^{n+1}_{E}=U^{n+1}(\Sigma^{n+1})(V^{n+1})^T$ 得到下一步中的弹性形变分量。</p>
<p>最后，通过$F_P^{n+1}=(F^{n+1}_E)^{-1} F^{n+1}$ 求得该步骤得到的塑性形变。</p>
<p>雪材质的一大特点为挤压时受力更大，这可以被建模为受到挤压时，其$\mu$ 和$\lambda$ 增大($\mu$ 和$\lambda$ 见(7),(8),(9),(10) )。</p>
<script type="math/tex; mode=display">
\mu(F_P)=\mu_0e^{\sigma(1-J_p)}  \lambda(F_P)=\lambda_0e^{\sigma(1-J_P)}</script><h4 id="控制方程"><a href="#控制方程" class="headerlink" title="控制方程"></a>控制方程</h4><p>在拉格朗日视角下，令速度$V(X,t)=\frac{\partial \Phi(X,t)}{\partial t}$， 材质主要需要遵守物质守恒，动量守恒两条规则。令$R(X,t)=\rho(\Phi(X,t),t)$ 为密度函数。其中，物质守恒:</p>
<script type="math/tex; mode=display">
\int_{B^t} R(X,t) dx=\int_{B^0} R(X,0) dX\\
(由公式4) \int_{B^0} R(X,t) J(X,t)dX=\int_{B^0}R(X,0)dX\\
R(X,t)J(X,t)=R(X,0) (10)</script><p>其中$J(X,t)=det( \frac{\partial \Phi(X,t)}{\partial X})$</p>
<p>对于欧拉视角下的动量守恒可以将11改为</p>
<script type="math/tex; mode=display">
\frac{\partial}{\partial t}R(X,t)J(X,t)= 0\\
\frac{\partial R(X,t)}{\partial t} J(X,t) + R(X,t)\frac{\partial J(X,t)}{\partial t} = 0 (12)</script><p>其中对于$\frac{\partial J(X,t)}{\partial t}$ 有:</p>
<script type="math/tex; mode=display">
\frac{\partial J(X,t)}{\partial t}=\frac{\partial J}{\partial F} \cdot \frac{\partial F}{\partial t} (13)</script><p>对于$\frac{\partial J}{\partial F}$ ,由于$J=\sum F_{ik} adj(F)_{ki}  $ 其中$adj(F)$ 为$F$的伴随矩阵。则:</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial F}=\sum \frac{\partial F_{ik}}{\partial F_{ij}} adj(F)_{ki} + \frac{\partial adj(F)_{ki}}{\partial F_{ij}} F_{ik}</script><p> 由于伴随矩阵的元素$adj(F)_{ki}$ 和F第i行和第k列的元素无关，因此$\frac{\partial adj(F)_{ki}}{\partial F_{ij}}=0$</p>
<p>则$\frac{\partial J}{\partial F} =\Sigma \frac{\partial F_{ik}}{\partial F_{ij}} adj(F)_{ki}=  \sum \delta_{jk} adj(F)kj= adj(F)^T = JF^{-T}$</p>
<p>带入(13)中有:</p>
<script type="math/tex; mode=display">
\frac{\partial J}{\partial t} = JF^{-T} \frac{\partial F}{\partial t}=JF^{-T} \frac{\partial x}{\partial X\partial t}=JF^{-T}\frac{\partial V}{\partial X}=JF_{ji}^{-T}\frac{\partial v_i}{\partial x_k}F_{kj}=J\delta_{ki} \frac{\partial v_i}{\partial x_k}=J\frac{\partial v_i}{\partial x_i}=J(X,t) \bigtriangledown^x\cdot v(x,t) (14)</script><p>则将(14)带入(12)中有:</p>
<script type="math/tex; mode=display">
\frac{\partial R(X,t)}{\partial t} J(X,t) + R(X,t) J(X,t) \bigtriangledown^xv(x,t)=0\\
\frac{\partial R(X,t)}{\partial t}+R(X,t)\bigtriangledown^x v(x,t)=0</script><p>将$R(X,t)$ push forward有:</p>
<script type="math/tex; mode=display">
\frac{D \rho(x,t)}{D t} + \rho(x,t) \bigtriangledown^x v(x,t)=0 (14)</script><p>对于动量守恒，对于物体内部的受力场$t(x,n,t)$ 有:</p>
<script type="math/tex; mode=display">
t(x,n,t)=\sigma(x,t)  n</script><p>则动量守恒有:</p>
<script type="math/tex; mode=display">
\frac{d}{dt} \int_{B^t} \rho(x,t)v(x,t)dx= \int_{\partial  B^t} \sigma(x,t) n ds(x) + \int_{B^t}f_{ext} dx</script><p>对于方程的左边:</p>
<script type="math/tex; mode=display">
\frac{d}{dt}\int_{B^t} \rho(x,t)v(x,t)dx\\
=\frac{d}{dt} \int_{B^0} R(X,t)V(X,t)J(X,t)dX</script><p>由于质量守恒$R(X,t)J(X,t)=R(X,0)$ </p>
<script type="math/tex; mode=display">
\frac{d}{dt} \int_{B^0} R(X,0)V(X,t)dX=\int_{B^0}R(X,0)A(X,t)dX=\int_{B^0} R(X,t) A(X,t)J(X,t)dX</script><p>对于方程右边:</p>
<script type="math/tex; mode=display">
\int_{\partial B^t} \sigma(x,t) nds(x) + \int_{B^t} f_{ext}dx\\
=\int_{B^t} \bigtriangledown^x \cdot \sigma(x,t) + f_{ext}</script><p>将方程左边全部push forward有:</p>
<script type="math/tex; mode=display">
\int_{B^t} \rho(x,t)a(x,t)dx=\int_{B^t} \bigtriangledown^x\cdot \sigma(x,t) + f_{ext}dx\\
\rho a=\bigtriangledown^x\cdot \sigma(x,t) + f_{ext} (15)</script><p>该方程为欧拉视角下的形式。</p>
<p>同样的，可以对方程的左边做pull back:</p>
<script type="math/tex; mode=display">
\int_{\partial B^t} \sigma(x,t)nds= \int_{\partial  B^0} \sigma (x,t)JF^{-T}  NdS (公式5)</script><p>由于$J\sigma F^{-T}=P$ (公式6):</p>
<script type="math/tex; mode=display">
=\int_{\partial B^0}PNdS=\int_{B^0} \bigtriangledown^X \cdot P dX (16)</script><p>将16带入方程得:</p>
<script type="math/tex; mode=display">
\int_{B^0}R(X,t)A(X,t)J(X,t)dX=\int_{B_0} \bigtriangledown^X \cdot P + F_{ext}(X,t) J(X,t)dX\\
R(X,0)A(X,t)=\bigtriangledown^X\cdot P + F_{ext}(X,t) J(X,t) (17)</script><h4 id="方程的弱解"><a href="#方程的弱解" class="headerlink" title="方程的弱解"></a>方程的弱解</h4><p>对于拉格朗日视角下的动量守恒方程(17)，忽略外力项$F_{ext}$</p>
<script type="math/tex; mode=display">
R(X,0)A(X,t)=\triangledown^X \cdot P</script><p>对点乘任意函数$Q(.,t):\Omega^0\to R^d$并积分</p>
<script type="math/tex; mode=display">
\int_{B^0}  R(X,0) Q(X,t) \cdot A(X,t) dX=\int_{B^0} Q(X,t) \cdot (\bigtriangledown^X \cdot P) dX\\
\int_{B^0}R(X,0)Q_{i}(X,t)A_{i}(X,t)=\int_{B^0} Q_i(X,t) P_{ij} \frac{\partial }{\partial X_j} dX\\
=\int_{B^0} \frac{\partial }{\partial X_j}(Q_i(X,t)P_{ij})-\frac{\partial Q_i(X,t)}{\partial X_j} P_{ij} dX (分部积分)\\
=\int_{B^0}\frac{\partial}{\partial X_j} (Q_i(X,t)P_{ij})dX-\int_{B^0} \frac{\partial Q_i(X,t)}{\partial X_j}P_{ij} dX\\
=\int_{\partial B^0} Q_i(X,t)P_{ij}N_j dS- \int_{B^0}\frac{\partial Q_i(X,t)}{\partial X_j}P_{ij} dX (18)</script><p> 对于欧拉视角的方程假设$Q(X,t)=q(\phi(X,t),t)$ 则</p>
<script type="math/tex; mode=display">
\frac{\partial Q_i}{\partial X_j}= \frac{\partial q_i}{\partial x_k}\frac{\partial x_k}{\partial X_j}=\frac{\partial q_i}{\partial x_k} F_{kj}</script><p>又由于公式(6):</p>
<script type="math/tex; mode=display">
\frac{\partial Q_i(X,t)}{\partial X_j}P_{ij}dX=\frac{\partial q(x,t)_i}{\partial x_j} P_{ik}F_{kj}\frac{1}{J}dx=\frac{\partial q(x,t)_i}{\partial x_j} \sigma_{ij}(x,t) dx\\
Q_i(X,t) P_{ij}N_jdS=q_i(x,t) P_{ik} F_{kj}n_j\frac{1}{J} ds=q_i(x,t)\sigma_{ij}(x,t)n_j ds</script><p>则公式(18)在欧拉视角下的形式是:</p>
<script type="math/tex; mode=display">
\int_{B^t} \rho(x,t) q_i(x,t) a_i(x,t) dx=\int_{\partial B^t} q_i(x,t)\sigma_{ij}(x,t)n_j ds-\int_{B^t} \frac{\partial q_i(x,t)}{\partial x_j} \sigma_{ij}(x,t)dx (19)</script><p>这里$\sigma_{ij}n_j/P_{ij}N_j$ 可以看成是物体表面所受压力$t_i/T_i$。</p>
<h4 id="物质点"><a href="#物质点" class="headerlink" title="物质点"></a>物质点</h4><p>在MPM中，会在计算advection时将物质表示为物质点，在拉格朗日视角下模拟。而在计算物质点之间的压力场时，则会将物质点投影到欧拉网格上，在欧拉视角下求解。物质点到网格的来回投影需要差值函数，一般的，cubic样条和Quadratic样条都是比较常用的函数</p>
<script type="math/tex; mode=display">
N_{quadratic}(x)=\left\{\begin{matrix}
 \frac{3}{4}-|x|^2 & 0 \le |x| < \frac{1}{2} \\ \frac{1}{2}(\frac{3}{2}-|x|)^2& \frac{1}{2} \le |x| < \frac{3}{2}
 \\0& \frac{3}{2} \le |x|
\end{matrix}\right.</script><script type="math/tex; mode=display">
N_{cubic} =\left\{\begin{matrix}
 \frac{1}{2}|x|^3 - |x|^2 + \frac{2}{3} & 0 \le |x| < 1 \\ \frac{1}{6}(2-|x|)^3& 1 \le |x| < 2
 \\0& 2 \le |x|
\end{matrix}\right.</script><p>而对每个物质点$p$，都会通过样条函数计算一个相对网格$i(i=(x,y,z)/(x,y))$ 的权重:</p>
<script type="math/tex; mode=display">
w_{ip}=N_i(x_p)=N(\frac{1}{h}(x_p-x_i))N(\frac{1}{h}(y_p-y_i))N(\frac{1}{h}(z_p-z_i)) (为什么不直接用半径r?) (20)</script><p>对于系统中的每个物质点，可以定义其质量为$m_{p}^n=\int_{B_{\Delta x,p}^{t^n}} \rho(x,t^n) dx$ </p>
<p>则可以定义由拉格朗日视角下物质点的质量/动量转移到欧拉网格下的公式:</p>
<script type="math/tex; mode=display">
m_i=\sum_{p} m_p N_i(x_p)(21)\\
(mv)_i=\sum_{p} m_p v_p N_i(x_p)(22)</script><p>根据动量以及质量转移，可以推得各个网格的速度:</p>
<script type="math/tex; mode=display">
v_i=\frac{(mv)_i}{m_i}(23)</script><p>从网格到质点的转移类似，由于在模拟时一般假设质点的质量不变，因此只需要转移其速度</p>
<script type="math/tex; mode=display">
v_p = \sum_i v_i N_p(x_i) (24)</script><h4 id="时间离散化"><a href="#时间离散化" class="headerlink" title="时间离散化"></a>时间离散化</h4><p>将(19)时间离散化有:</p>
<script type="math/tex; mode=display">
\frac{1}{\Delta t}\int_{B^{t^n}} \rho(x,t^n) q_{\alpha}(x,t^n) (v^{n+1}_\alpha(x)-v^n_\alpha(x)) dx=\int_{\partial B^{t^n}} q_\alpha(x,t^n)\sigma_{\alpha \beta}(x,t^n)n_\beta ds-\int_{B^t} \frac{\partial q_\alpha(x,t^n)}{\partial x_\beta} \sigma_{\alpha \beta}(x,t^n)dx (25)</script><p>这里$v(x,t)$函数被离散化为了不同$t$ 中的速度场$v^n$ </p>
<p>这里将下标表示中的$i,j,k \in{1,2,3}$ 换为了$\alpha,\beta,\gamma$ 以免和表示euler grid序号的$i$ 冲突</p>
<p>需要注意的是$v_i(x,t^{n+1})=v_i(\phi^{-1}(X,t^n),t^{n+1}), v_i(x,t^n)=v_i(\phi^{-1}(X,t^n),t^n)$</p>
<h4 id="空间离散化"><a href="#空间离散化" class="headerlink" title="空间离散化"></a>空间离散化</h4><p>将$q_\alpha,v_\alpha$ 空间离散化有</p>
<script type="math/tex; mode=display">
q_\alpha(x,t^n)=\sum_{i} q^i_\alpha (t^n)N_i(x)\\
v_{\alpha}^{n+1}(x)=\sum_i v^{n+1\cdot i}_\alpha N_i(x)\\
v_\alpha^n(x)=\sum_i v_{\alpha}^{n\cdot i} N_i(x)</script><p>其中$v_\alpha^{n\cdot i},v_\alpha^{n+1\cdot i},q^i_\alpha$ 均为对应函数在第$i$ 个网格上的值。离散化后的结果带入式（25）</p>
<script type="math/tex; mode=display">
\frac{1}{\Delta t}\int_{B^{t^n}} \rho(x,t^n) q^i_\alpha (t^n)N_i(x) (v^{n+1\cdot j}_\alpha N_j(x)-\sum_i v_{\alpha}^{n\cdot j} N_j(x)) dx=\int_{\partial B^{t^n}}  q^i_\alpha (t^n)N_i(x) \sigma_{\alpha \beta}(x,t^n)n_\beta ds-\int_{B^t} q^i_\alpha (t^n) \frac{\partial N_i(x)}{\partial x_\beta} \sigma_{\alpha \beta}(x,t^n)dx</script><p>这里i,j等下标的求和符号均被省略</p>
<p>令$m_{ij}=\int_{B^{t^n}} N_i(x) \rho(x,t^n) N_j(x) dx$</p>
<p>原式左手:</p>
<script type="math/tex; mode=display">
=q_\alpha^i(t^n) v_{\alpha}^{n+1\cdot j} \frac{m_{ij}}{\Delta t}-q_\alpha^i(t^n) v_{\alpha}^{n\cdot j} \frac{m_{ij}}{\Delta t}</script><p>由于该式对任意$q_\alpha^i$ 取值均成立，因此可以令$q_\alpha^i(t^n)= \left\{\begin{matrix}<br> 1 &amp; i=\hat i ,\alpha = \hat \alpha\\<br> 0 &amp; else<br>\end{matrix}\right.$</p>
<p>则原式等于</p>
<script type="math/tex; mode=display">
\sum_j \frac{m_{\hat i j}}{\Delta t} (v_{\hat \alpha}^{n+1 \cdot j}- v^{n\cdot j}_{\hat \alpha})=\int_ {\partial B^{t^n}} \sum_{\beta} N_{\hat i}(x) \sigma_{\hat \alpha \beta}(x, t^n)n_\beta ds-\int_{B^t} \sum_{\beta} \frac{\partial N_\hat i(x)}{\partial x_{\beta}}\sigma_{\hat \alpha \beta} (x,t^n) dx (26)</script><p>者可以视作对$\hat i, \hat \alpha$ 在欧拉网格上的离散化形式。对于质量$m_{ij}$ 一种优化方法便是直接将其替换为行值之和的对角矩阵:</p>
<script type="math/tex; mode=display">
\hat m_{i}=\hat m_{ii}=\sum_{j}m_{ij}=\sum_{j}\int_{B^t} N_i(x) \rho(x,t^n)N_j(x)dx\approx \int_{B^t}N_i(x)\rho(x,t^n)dx</script><p>由于$\rho(x,t^n)dx$ 的pull back是$R(X,0)dX$且$m_p=\int_{B_p^0}R(X,0)dX$</p>
<script type="math/tex; mode=display">
=\int_{B^0} N_i(x(X))R(X,0)dX\approx \sum_p N_i(x_p)m_p (27)</script><p>将(27)带入(26)中可得</p>
<script type="math/tex; mode=display">
\frac{m_{\hat i}}{\Delta t}(v^{n+1\cdot \hat i}_\hat \alpha-v^{n\cdot \hat i}_\hat \alpha)=\frac{(mv)^{n+1\cdot \hat i}_{\hat \alpha}-(mv)^{n\cdot \hat i}_\hat \alpha}{\Delta t} = \int_ {\partial B^{t^n}} \sum_{\beta} N_{\hat i}(x) \sigma_{\hat \alpha \beta}(x, t^n)n_\beta ds-\int_{B^t} \sum_{\beta} \frac{\partial N_\hat i(x)}{\partial x_{\beta}}\sigma_{\hat \alpha \beta} (x,t^n) dx (28)</script><p>对于每个质点$p$ 都有$\sigma^n_p=\sigma(x_p, t^n)$ ，假设将整个$B^t$ 分成和粒子数相同的小单元，且每个单元内压力相同，则对于式(28)减号的右边:</p>
<script type="math/tex; mode=display">
\approx \sum_{\beta} \sum_p \frac{\partial N_i(x_p^n)}{\partial x_\beta} (\sigma^n_p)_{\hat \alpha \beta}(x,t^n)V_p^n</script><p>将其带入(28)中得到:</p>
<script type="math/tex; mode=display">
\frac{(mv)^{n+1\cdot \hat i}_{\hat \alpha}-(mv)^{n\cdot \hat i}_\hat \alpha}{\Delta t} = \int_ {\partial B^{t^n}} \sum_{\beta} N_{\hat i}(x) \sigma_{\hat \alpha \beta}(x, t^n)n_\beta ds -\sum_{\beta}  \sum_p  \frac{\partial N_i(x)}{\partial x_\beta} (\sigma^n_p)_{\hat \alpha \beta}(x,t^n)V_p^n (29)</script><p>对于粒子$p$的体积项$V_p^n$,有两种计算方法:</p>
<script type="math/tex; mode=display">
m_p\approx \rho(x_p,t^n)V_p^n</script><p>而对于$p$ 点的密度，可以通过附近网格点的质量$m_i^n$间接估计:</p>
<script type="math/tex; mode=display">
\rho_i^n=\frac{m_i^n}{(\Delta x)^d}\\
\rho(x_p,t^n)= \sum_i \rho_i^nN_p(x_i)</script><p>其中$\Delta x$ 为欧拉网格边长，当网格为2维时$d=2$,当网格为3维时$d=3$,最后得到</p>
<script type="math/tex; mode=display">
V_p^n= \frac{m_p}{\rho(x_p,t^n)}=\frac{m_p}{\sum_i \rho_i^nN_p(x_i)}=\frac{m_p}{\sum_i \frac{m_i^n}{(\Delta x)^d}N_p(x_i)}=\frac{m_p (\Delta x)^d}{\sum_i m_i^n N_p(x_i)} (30)</script><p>另一种方法则为将整个积分域由$B^{t^n}$转到$B^0$ :</p>
<script type="math/tex; mode=display">
V_p^n=\int_{B^{t^n}}dx=\int_{B^0}J(x(X_p),t^n)dX \approx J_p^n V_p^0 (31)</script><p>将公式(6)以及(31)带入(29)减号右边得到:</p>
<script type="math/tex; mode=display">
\sum_p  \frac{\partial N_i(x)}{\partial x_\beta} (\sigma^n_p)_{\hat \alpha \beta}(x,t^n)V_p^n=\sum_p \frac{\partial N_i(x)}{\partial x_\beta} \frac{1}{J_p^n}(P^n_p)_{\hat \alpha \gamma} {(F_p^n)}_{\beta \gamma} V_p^0J_p^n=\sum_p \frac{\partial N_i(x_p)}{\partial x_{\beta}}(P_p^n)_{\hat \alpha \gamma} (F_p^n)_{\beta \gamma} V_p^0</script><p>将上式带入(28)中得:</p>
<script type="math/tex; mode=display">
\frac{(mv)^{n+1\cdot \hat i}_{\hat \alpha}-(mv)^{n\cdot \hat i}_\hat \alpha}{\Delta t} = \int_ {\partial B^{t^n}} \sum_{\beta} N_{\hat i}(x) \sigma_{\hat \alpha \beta}(x, t^n)n_\beta ds -\sum_\beta\sum_p \frac{\partial N_i(x_p)}{\partial x_{\beta}}(P_p^n)_{\hat \alpha \gamma} (F_p^n)_{\beta \gamma} V_p^0 (31)</script><h4 id="计算形变梯度"><a href="#计算形变梯度" class="headerlink" title="计算形变梯度"></a>计算形变梯度</h4><p>直接计算形变梯度在mpm里是十分困难的,但是可以通过时间离散化后更新其值来估计。根据公式(2.1)有:</p>
<script type="math/tex; mode=display">
\frac{dF}{dt}(x,t)=\frac{\partial v}{\partial x}(x,t) F(x,t)</script><p>对于$F_p^n$ ，做时间离散化得:</p>
<script type="math/tex; mode=display">
\frac{F^{n+1}_p-F^n_p}{\Delta t}=\frac{\partial v}{\partial x}(x_p,t^{n+1})F_p^n\\
F_p^{n+1}=(I+\Delta t \frac{\partial v}{\partial x}(x_p,t^{n+1}))F_p^n(32)</script><p> 对$v(x_p,t^{n+1})$ 可以根据欧拉网格估计:</p>
<script type="math/tex; mode=display">
v(x_p,t^{n+1})=\sum_i v_i^{n+1}N_p(x_i)\\
\frac{\partial v}{\partial x}(x_p,t^{n+1})= \sum_i v_i^{n+1}(\frac{\partial N_p}{\partial x}(x_i))^T</script><p>将上式带入(32)得:</p>
<script type="math/tex; mode=display">
F_p^{n+1}= (I+\Delta t \sum_i v_i^{n+1}(\frac{\partial N_p}{\partial x}(x_i))^T)F_p^n (33)</script><h4 id="潜在能量和受力"><a href="#潜在能量和受力" class="headerlink" title="潜在能量和受力"></a>潜在能量和受力</h4><p>假设欧拉网格点的位置会随着时间运动（TODO  定义$\hat x_i, x_i$）</p>
<p>对于系统的潜在能量函数可以被定义为:</p>
<script type="math/tex; mode=display">
e(\hat x)=\sum_p \psi(F(\hat x)) V_p^0</script><p>根据拉格朗日方程，我们可以通过对潜在能函数求广义坐标的导数分析系统受力。（动机）</p>
<p>对其某个粒子的位置$\hat x_{ i \alpha}$求导有:</p>
<script type="math/tex; mode=display">
\frac{\partial e(\hat x)}{\partial \hat x_{i\alpha}}= \sum_{p,\beta,\gamma} (\frac{\partial \psi}{\partial F})_{\beta\gamma} \cdot (\frac{\partial F}{\partial \hat x_{i\alpha}})_{\beta \gamma}  V_p^0\\
=\sum_{p,\beta,\gamma}P_{\beta \gamma}(F_p(\hat x)) \frac{\partial (F_p)_{\beta \gamma}}{\partial \hat x_{i\alpha}} V_p^0 (34)</script><p>（TODO）其速度可以表达为$v^{n+1}_i=\frac{\hat x_i-x_i}{\Delta t}$ ,其中$\hat x_i$ 为该网格点的新位置。将该式带入(33)式得(注$N_p(x_i)=N_i(x_p)$):</p>
<script type="math/tex; mode=display">
(F_p^{n+1})_{\beta \gamma}=(I+\Delta t \sum_i \frac{ (\hat x_i)_{\beta}-(x_i)_{\beta}}{\Delta t} \sum_{\tau } \frac{\partial N_i}{\partial x_\tau}(x_p^n))(F_p^n)_{\tau \gamma}</script><p>对$(F^{n+1}_p)_{\beta \gamma}$ 求导有:</p>
<script type="math/tex; mode=display">
\frac{\partial (F_p^{n+1})_{\beta \gamma}}{\partial \hat x_{i\alpha}}=\delta_{\alpha\beta} \sum_{\tau} \frac{\partial N_i}{\partial x_{\tau}}(x_p)(F_p^n)_{\tau \gamma} (35)</script><p>将(35)带入(34)有:</p>
<script type="math/tex; mode=display">
\frac{\partial e(\hat x)}{\partial \hat x_{i\alpha}}=\sum_{p,\beta,\gamma}P_{\beta \gamma}(F_p(\hat x))\delta_{\alpha\beta} \sum_{\tau} \frac{\partial N_i}{\partial x_{\tau}}(x_p)(F_p^n)_{\tau \gamma}   V_p^0 \\
=\sum_{p,\gamma,\tau} P_{\alpha \gamma}(F_p(\hat x)) \frac{\partial N_i}{\partial x_{\tau}}(x_p)(F_p^n)_{\tau \gamma} V_p^0 (36)</script><p>对比(36)和(31)减号后半部分，不难发现:</p>
<script type="math/tex; mode=display">
\frac{(mv)^{n+1\cdot \hat i}_{\hat \alpha}-(mv)^{n\cdot \hat i}_\hat \alpha}{\Delta t} = \int_ {\partial B^{t^n}} \sum_{\beta} N_{\hat i}(x) \sigma_{\hat \alpha \beta}(x, t^n)n_\beta ds - \frac{\partial e}{\partial \hat x_{i\alpha}}(\hat x=\begin{pmatrix}
 x_0\\
 x_1\\
 ...\\
x_i
\end{pmatrix} ) (37)</script><p>其中$\hat x = \begin{pmatrix}<br> x_0\\<br> x_1\\<br> …\\<br>x_i<br>\end{pmatrix}$ 为所有欧拉网格位置构成的广义坐标。</p>
<h2 id="显式前向欧拉"><a href="#显式前向欧拉" class="headerlink" title="显式前向欧拉"></a>显式前向欧拉</h2><h4 id="APIC"><a href="#APIC" class="headerlink" title="APIC"></a>APIC</h4><p>相比传统的PIC，APIC对从粒子到网格动量的transfer过程做了部分改动。</p>
<script type="math/tex; mode=display">
m_i=\sum_p m_pN_i(x_p)  (e.1)\\
(mv)_i= \sum_{p}w_{ip} m_p (v_p + B_p (D_p)^{-1}(x_i - x_p)) (e.2)</script><p>关于(e.2)公式的详细说明可以见论文笔记 The Affine Particle-In-Cell Method(TODO)</p>
<p>其中$B_p$ 矩阵会被存到每个粒子点中，随着每步迭代更新。</p>
<p>其中$D_p^n= \sum_i w_{ip}^n (x_i-x_p^n)(x_i- x_p^n)^T $ ，当采用cubic样条函数时，$D_p^n=\frac{1}{3}\Delta x^2 I$ ，当采用quadric样条时，$D_p^n= \frac{1}{4} \Delta x^2 I$  </p>
<h4 id="更新形变梯度"><a href="#更新形变梯度" class="headerlink" title="更新形变梯度"></a>更新形变梯度</h4><p>根据公式(33)可得每个粒子的形变梯度$F$ 的更新规则为:</p>
<script type="math/tex; mode=display">
F^{n+1}_p=(I+\Delta t \sum_i v_i^{n+1}(\bigtriangledown^x w_{ip})^T) F_p^n (e.3)</script><h4 id="计算受力"><a href="#计算受力" class="headerlink" title="计算受力"></a>计算受力</h4><p>根据公式(36)可以计算各个欧拉网格在不同时间点的受力公式:</p>
<script type="math/tex; mode=display">
f_i(x)=-\frac{\partial e}{\partial x_i}=-\sum_{p} P(F_p^n(x)) (F_p^n)^T \cdot \bigtriangledown^x w_{ip} V_p^0 (e.4)</script><h4 id="完整步骤"><a href="#完整步骤" class="headerlink" title="完整步骤"></a>完整步骤</h4><p>整个过程分为以下几步：</p>
<ol>
<li><p>从粒子通过(e.1),(e.2)transfer到欧拉网格</p>
</li>
<li><p>计算网格速度$v^n_i=\frac{mv_i^n}{m_i^n}$ 对于质量等于0的质点将其速度设置为0。</p>
</li>
<li>（可选）标记质量非0的网格，在后续的模拟中只考虑这些网格。</li>
<li>根据公式(e.4), 计算网格受力$f_i^n$</li>
<li>更新网格速度$v_i^{n+1}=v_i^n + \Delta t \frac{f_i^n}{m_i^n}$</li>
<li>更新网格形变梯度根据公式(e.3)</li>
<li>将网格速度重新投影回各个粒子上$v_p^{n+1} = \sum_i w_{ip} v_i^{n+1} (e.5), x_p^{n+1} =x_p + \Delta t v_p^{n+1} (e.6)$</li>
</ol>
<h4 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h4><p>一个navie版本的基于前向欧拉的mpm实现如下所示 (数据声明以及场景设定的代码来自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97700605">https://zhuanlan.zhihu.com/p/97700605</a>)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> taichi <span class="keyword">as</span> ti</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">ti.init(arch=ti.gpu) <span class="comment"># Try to run on GPU</span></span><br><span class="line">quality = <span class="number">1</span> <span class="comment"># Use a larger value for higher-res simulations</span></span><br><span class="line">n_particles, n_grid = <span class="number">6000</span> * quality ** <span class="number">2</span>, <span class="number">128</span> * quality</span><br><span class="line">dx, inv_dx = <span class="number">1</span> / n_grid, <span class="built_in">float</span>(n_grid)</span><br><span class="line">drt = <span class="number">2e-3</span></span><br><span class="line">dt = <span class="number">1e-4</span> / quality</span><br><span class="line">p_vol, p_rho = (dx * <span class="number">0.5</span>)**<span class="number">2</span>, <span class="number">1</span></span><br><span class="line">p_mass = p_vol * p_rho</span><br><span class="line">E, nu = <span class="number">0.1e4</span>, <span class="number">0.2</span> <span class="comment"># Young&#x27;s modulus and Poisson&#x27;s ratio</span></span><br><span class="line">mu_0, lambda_0 = E / (<span class="number">2</span> * (<span class="number">1</span> + nu)), E * nu / ((<span class="number">1</span>+nu) * (<span class="number">1</span> - <span class="number">2</span> * nu)) <span class="comment"># Lame parameters</span></span><br><span class="line">x = ti.Vector.field(<span class="number">2</span>, dtype=<span class="built_in">float</span>, shape=n_particles) <span class="comment"># position</span></span><br><span class="line">v = ti.Vector.field(<span class="number">2</span>, dtype=<span class="built_in">float</span>, shape=n_particles) <span class="comment"># velocity</span></span><br><span class="line">F = ti.Matrix.field(<span class="number">2</span>, <span class="number">2</span>, dtype=<span class="built_in">float</span>, shape=n_particles) <span class="comment"># deformation gradient</span></span><br><span class="line">material = ti.field(dtype=<span class="built_in">int</span>, shape=n_particles) <span class="comment"># material id</span></span><br><span class="line">grid_v = ti.Vector.field(<span class="number">2</span>, dtype=<span class="built_in">float</span>, shape=(n_grid, n_grid)) <span class="comment"># grid node momentum/velocity</span></span><br><span class="line">grid_m = ti.field(dtype=<span class="built_in">float</span>, shape=(n_grid, n_grid)) <span class="comment"># grid node mass</span></span><br><span class="line">grid_f = ti.Vector.field(<span class="number">2</span>, dtype=<span class="built_in">float</span>, shape=(n_grid, n_grid))</span><br><span class="line">g = ti.Vector([<span class="number">0</span>, -<span class="number">50</span>]) </span><br><span class="line">h = <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.func</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_grid_idx</span>(<span class="params">idx, i, j</span>):</span><br><span class="line">  res = idx + ti.Vector([i, j])</span><br><span class="line">  <span class="keyword">return</span> ti.math.clamp(res, <span class="number">0</span>, n_grid)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">p2g</span>():</span><br><span class="line">  <span class="comment"># 初始化网格，所有值设置为0 </span></span><br><span class="line">  <span class="keyword">for</span> i,j <span class="keyword">in</span> grid_v:</span><br><span class="line">    grid_v[i, j] = ti.Vector([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    grid_m[i, j] = <span class="number">0</span></span><br><span class="line">    grid_f[i, j] = ti.Vector([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(n_particles):</span><br><span class="line">    x_p = x[p]</span><br><span class="line">    v_p = v[p] </span><br><span class="line">    F_p = F[p]</span><br><span class="line"></span><br><span class="line">    U, sig, V = ti.svd(F_p)</span><br><span class="line">    J = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">      J *= sig[d, d]</span><br><span class="line"></span><br><span class="line">    mu, la = h * mu_0, lambda_0 * h</span><br><span class="line">    PFTV = (<span class="number">2</span> * mu * (F_p - U @ V.transpose()) @ F_p.transpose() + la *  (J - <span class="number">1</span>) * J) * p_vol</span><br><span class="line"></span><br><span class="line">    x_i_m_1 = (x_p * inv_dx + <span class="number">0.5</span>).cast(<span class="built_in">int</span>) - <span class="number">1</span></span><br><span class="line">    fx = x_p * inv_dx - x_i_m_1.cast(<span class="built_in">float</span>) </span><br><span class="line">    </span><br><span class="line">    w = [<span class="number">0.5</span> * (<span class="number">1.5</span> -  fx) ** <span class="number">2</span>, <span class="number">0.75</span> - (fx - <span class="number">1</span>) ** <span class="number">2</span>, <span class="number">0.5</span> * (fx - <span class="number">0.5</span>) ** <span class="number">2</span>]</span><br><span class="line">    dw = [(fx - <span class="number">1.5</span>) * inv_dx, (<span class="number">2.0</span> - <span class="number">2.0</span> * fx) * inv_dx, (fx - <span class="number">0.5</span>) * inv_dx] </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i,j <span class="keyword">in</span> ti.static(ti.ndrange(<span class="number">3</span>, <span class="number">3</span>)):</span><br><span class="line">      w_ij = w[i][<span class="number">0</span>] * w[j][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">      grid_idx = get_grid_idx(x_i_m_1, i, j)</span><br><span class="line"></span><br><span class="line">      <span class="comment">#transfer速度和动量</span></span><br><span class="line">      grid_m[grid_idx] += p_mass * w_ij</span><br><span class="line">      grid_v[grid_idx] += p_mass * v_p * w_ij </span><br><span class="line">      grid_f[grid_idx] += - PFTV @ ti.Vector([ dw[i][<span class="number">0</span>] * w[j][<span class="number">1</span>], w[i][<span class="number">0</span>] * dw[j][<span class="number">1</span>]])</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">g2p</span>():</span><br><span class="line">  <span class="keyword">for</span> i, j <span class="keyword">in</span> grid_v:</span><br><span class="line">    <span class="keyword">if</span> grid_m[i, j] == <span class="number">0</span>:</span><br><span class="line">      grid_v[i, j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 更新网格状态</span></span><br><span class="line">      <span class="comment"># 由网格动量计算速度</span></span><br><span class="line">      grid_v[i, j] = grid_v[i, j] / grid_m[i, j]</span><br><span class="line">      <span class="comment"># advection</span></span><br><span class="line">      grid_v[i, j] += (g + grid_f[i, j] / grid_m[i, j]) * dt </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解决边界条件</span></span><br><span class="line">    <span class="keyword">if</span> i == n_grid - <span class="number">1</span>:</span><br><span class="line">      grid_v[i, j][<span class="number">0</span>] = <span class="built_in">min</span>(grid_v[i, j][<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">      grid_v[i, j][<span class="number">0</span>] = <span class="built_in">max</span>(grid_v[i, j][<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> j == n_grid - <span class="number">1</span>:</span><br><span class="line">      grid_v[i, j][<span class="number">1</span>] = <span class="built_in">min</span>(grid_v[i, j][<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">      grid_v[i, j][<span class="number">1</span>] = <span class="built_in">max</span>(grid_v[i, j][<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">      grid_v[i, j][<span class="number">0</span>] *= <span class="number">0.8</span> <span class="comment">#地面摩擦力</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(n_particles):</span><br><span class="line">    x_p = x[p]</span><br><span class="line"></span><br><span class="line">    x_i_m_1 = (x_p * inv_dx + <span class="number">0.5</span>).cast(<span class="built_in">int</span>) - <span class="number">1</span></span><br><span class="line">    fx = x_p * inv_dx - x_i_m_1.cast(<span class="built_in">float</span>) </span><br><span class="line"></span><br><span class="line">    w = [<span class="number">0.5</span> * (<span class="number">1.5</span> -  fx) ** <span class="number">2</span>, <span class="number">0.75</span> - (fx - <span class="number">1</span>) ** <span class="number">2</span>, <span class="number">0.5</span> * (fx - <span class="number">0.5</span>) ** <span class="number">2</span>]</span><br><span class="line">    dw = [(fx - <span class="number">1.5</span>) * inv_dx, (<span class="number">2.0</span> - <span class="number">2.0</span> * fx) * inv_dx, (fx - <span class="number">0.5</span>) * inv_dx] </span><br><span class="line"></span><br><span class="line">    F_p = F[p]</span><br><span class="line">    new_F_p = F_p</span><br><span class="line">    new_v_p = ti.Vector([<span class="number">0</span>, <span class="number">0</span>], dt=<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i,j <span class="keyword">in</span> ti.static(ti.ndrange(<span class="number">3</span>, <span class="number">3</span>)):</span><br><span class="line">    <span class="comment">#更新网格的p值</span></span><br><span class="line">      grad_w_ip = ti.Vector([ dw[i][<span class="number">0</span>] * w[j][<span class="number">1</span>], w[i][<span class="number">0</span>] * dw[j][<span class="number">1</span>]])</span><br><span class="line">      w_ip = w[i][<span class="number">0</span>] * w[j][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">      grid_idx = get_grid_idx(x_i_m_1, i, j)</span><br><span class="line">      </span><br><span class="line">      v_i = grid_v[grid_idx]</span><br><span class="line">      new_F_p += dt *  v_i.outer_product(grad_w_ip) @ F_p</span><br><span class="line">      new_v_p += w_ip * v_i</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    F[p] = new_F_p</span><br><span class="line">    v[p] = new_v_p</span><br><span class="line">    x[p] += new_v_p * dt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group_size = n_particles // <span class="number">2</span></span><br><span class="line"><span class="meta">@ti.kernel</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">initialize</span>():</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_particles):</span><br><span class="line">    x[i] = [ti.random() * <span class="number">0.2</span> + <span class="number">0.3</span> + <span class="number">0.10</span> * (i // group_size), ti.random() * <span class="number">0.2</span> + <span class="number">0.05</span> + <span class="number">0.32</span> * (i // group_size)]</span><br><span class="line">    material[i] = i // group_size  <span class="comment"># 0: snow 1: jelly </span></span><br><span class="line">    v[i] = ti.Matrix([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    F[i] = ti.Matrix([[<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">initialize()</span><br><span class="line">gui = ti.GUI(<span class="string">&quot;navie mpm&quot;</span>, res=<span class="number">512</span>, background_color=<span class="number">0x112F41</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> gui.get_event(ti.GUI.ESCAPE, ti.GUI.EXIT):</span><br><span class="line">  <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(drt // dt)):</span><br><span class="line">    p2g()</span><br><span class="line">    g2p()</span><br><span class="line">  </span><br><span class="line">  colors = np.array([<span class="number">0xEEEEF0</span>, <span class="number">0xED553B</span>, <span class="number">0xEEEEF0</span>], dtype=np.uint32)</span><br><span class="line">  gui.circles(x.to_numpy(), radius=<span class="number">1.5</span>, color=colors[material.to_numpy()])</span><br><span class="line">  gui.show() <span class="comment"># Change to gui.show(f&#x27;&#123;frame:06d&#125;.png&#x27;) to write images to disk</span></span><br></pre></td></tr></table></figure>
<p>接下来本文将解读模拟的主体部分。</p>
<p>每个模拟步长分为初始化，粒子到网格，网格更新，网格到粒子4个部分。</p>
<p>在初始化阶段，需要把网格的质量，速度，力等属性清0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> grid_v:</span><br><span class="line">    grid_v[i, j] = ti.Vector([<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">    grid_m[i, j] = <span class="number">0</span></span><br><span class="line">    grid_f[i, j] = ti.Vector([<span class="number">0</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>接着在粒子到网格阶段，我们首先需要根据公式(e.4)计算各个粒子对应的力</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(n_particles):</span><br><span class="line">    x_p = x[p]</span><br><span class="line">    v_p = v[p] </span><br><span class="line">    F_p = F[p]</span><br><span class="line"></span><br><span class="line">    U, sig, V = ti.svd(F_p)</span><br><span class="line">    J = <span class="number">1.0</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">      J *= sig[d, d]</span><br><span class="line"></span><br><span class="line">    mu, la = h * mu_0, lambda_0 * h</span><br><span class="line">    PFTV = (<span class="number">2</span> * mu * (F_p - U @ V.transpose()) @ F_p.transpose() + la *  (J - <span class="number">1</span>) * J) * p_vol</span><br></pre></td></tr></table></figure>
<p>其中<code>PFTV</code> 为(e.4)中的$P(F_p^n(x)) (F_p^n)^TV_p^0$ 项，$P$ 我们采用了fixed corotated model，其形式如公式(10)所示。</p>
<p>接着，根据公式(e.1)以及(e.4) （由于目前我们的实现不是APIC因此动量的转换只是简单的$mv_i= \sum_p w_{ip} m_p v_p $）</p>
<p>我们将粒子的受力，质量以及动量转移到网格上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">...</span><br><span class="line">x_i_m_1 = (x_p * inv_dx + <span class="number">0.5</span>).cast(<span class="built_in">int</span>) - <span class="number">1</span></span><br><span class="line">fx = x_p * inv_dx - x_i_m_1.cast(<span class="built_in">float</span>) </span><br><span class="line"></span><br><span class="line">w = [<span class="number">0.5</span> * (<span class="number">1.5</span> -  fx) ** <span class="number">2</span>, <span class="number">0.75</span> - (fx - <span class="number">1</span>) ** <span class="number">2</span>, <span class="number">0.5</span> * (fx - <span class="number">0.5</span>) ** <span class="number">2</span>]</span><br><span class="line">dw = [(fx - <span class="number">1.5</span>) * inv_dx, (<span class="number">2.0</span> - <span class="number">2.0</span> * fx) * inv_dx, (fx - <span class="number">0.5</span>) * inv_dx] </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> ti.static(ti.ndrange(<span class="number">3</span>, <span class="number">3</span>)):</span><br><span class="line">  w_ij = w[i][<span class="number">0</span>] * w[j][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  grid_idx = get_grid_idx(x_i_m_1, i, j)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#transfer速度和动量</span></span><br><span class="line">  grid_m[grid_idx] += p_mass * w_ij</span><br><span class="line">  grid_v[grid_idx] += p_mass * v_p * w_ij </span><br><span class="line">  grid_f[grid_idx] += - PFTV @ ti.Vector([ dw[i][<span class="number">0</span>] * w[j][<span class="number">1</span>], w[i][<span class="number">0</span>] * dw[j][<span class="number">1</span>]])</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>其中，关于权重的计算，这里我们用了和个<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97700605">https://zhuanlan.zhihu.com/p/97700605</a> 类似的小trick。</p>
<p>在transfer过程中，一个粒子需要搜索其$3 \times 3$范围内的所有网格。 因此，我们在计算时通过$\left \lfloor \frac{x_p}{\Delta x}+ 0.5 \right \rfloor - 1$ ,可以得到粒子所在网格左下角一个网格的索引$i_{base}$。在遍历时，通过$i_{base} + [i,j],(i,j\in {0,1,2})$ 可以很方便的遍历所有 相邻网格。</p>
<p><img src="/images/phy1/mpm2.png" alt=""></p>
<p>令$fx = \frac{x_p - x_{i-1}}{\Delta x}$</p>
<script type="math/tex; mode=display">
N_{i-1}^p=N(\frac{x_p - x_{i-1}}{\Delta x})= \frac{1}{2}(\frac{3}{2}-fx)^2 (显然\frac{3}{2} > fx > \frac{1}{2} )\\
N_{i}^p=N(\frac{x_p - (x_{i-1} + \Delta x)}{\Delta x})= \frac{3}{4}-|fx-1|^2=\frac{3}{4}-(fx-1)^2(显然 -\frac{1}{2}<fx - 1<\frac{1}{2})\\
N_{i+1}^p=N(\frac{x_p - (x_{i-1}+2\Delta x)}{\Delta x})= \frac{1}{2}(\frac{3}{2} - |fx-2|)^2=\frac{1}{2}(fx-\frac{1}{2})^2(显然 -\frac{3}{2}< fx - 2 < -\frac{1}{2})</script><p>而对于第$i’, j’$ 个邻域网格，则:</p>
<script type="math/tex; mode=display">
w_{ip}=N(\frac{x_p-x_i}{\Delta x})N(\frac{y_p-y_i}{\Delta x})=N_{i+i'}^{p,x}N_{j+j'}^{p,y}</script><p>于是，便有</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x_i_m_1 = (x_p * inv_dx + <span class="number">0.5</span>).cast(<span class="built_in">int</span>) - <span class="number">1</span></span><br><span class="line">fx = x_p * inv_dx - x_i_m_1.cast(<span class="built_in">float</span>) </span><br><span class="line"></span><br><span class="line">w = [<span class="number">0.5</span> * (<span class="number">1.5</span> -  fx) ** <span class="number">2</span>, <span class="number">0.75</span> - (fx - <span class="number">1</span>) ** <span class="number">2</span>, <span class="number">0.5</span> * (fx - <span class="number">0.5</span>) ** <span class="number">2</span>]</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> ti.static(ti.ndrange(<span class="number">3</span>, <span class="number">3</span>)):</span><br><span class="line">      w_ij = w[i][<span class="number">0</span>] * w[j][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>对于$w_{ip}$ 的梯度，我们有:</p>
<script type="math/tex; mode=display">
\bigtriangledown \cdot w_{ip}=\frac{1}{\Delta x}\begin{pmatrix}
\frac{\partial N}{\partial x}(\frac{x_p-x_i}{\Delta x})N(\frac{y_p-y_i}{\Delta x}) \\
N(\frac{x_p-x_i}{\Delta x})\frac{\partial N}{\partial y}(\frac{y_p-y_i}{\Delta x})
\end{pmatrix}</script><p>令$\frac{\partial N}{\partial x}=\dot N$类似$N_i^p$ 我们可以定义:</p>
<script type="math/tex; mode=display">
\dot N_{i-1}^p=\dot N(\frac{x_p - x_{i-1}}{\Delta x})= (\frac{3}{2}-fx)\\
\dot N_{i}^p= \dot N(\frac{x_p - (x_{i-1} + \Delta x)}{\Delta x})= -2(fx-1)\\
\dot N_{i+1}^p= \dot N(\frac{x_p - (x_{i-1}+2\Delta x)}{\Delta x})= (fx-\frac{1}{2}))</script><p>则对于第$i’, j’$ 个邻域网格：</p>
<script type="math/tex; mode=display">
\bigtriangledown \cdot w_{ip}=\frac{1}{\Delta x}\begin{pmatrix}
\dot N(\frac{x_p-x_i}{\Delta x})N(\frac{y_p-y_i}{\Delta x}) \\
N(\frac{x_p-x_i}{\Delta x})\dot N(\frac{y_p-y_i}{\Delta x})
\end{pmatrix}
=\begin{pmatrix}
\dot N_{i+i'}^{p,x}N_{j+j'}^{p,y} \\
 N_{i+i'}^{p,x}\dot N_{j+j'}^{p,y}
\end{pmatrix}</script><p>这对应着代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dw = [(fx - <span class="number">1.5</span>) * inv_dx, (<span class="number">2.0</span> - <span class="number">2.0</span> * fx) * inv_dx, (fx - <span class="number">0.5</span>) * inv_dx]</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> i,j <span class="keyword">in</span> ti.static(ti.ndrange(<span class="number">3</span>, <span class="number">3</span>)):</span><br><span class="line">      ...</span><br><span class="line">      grid_f[grid_idx] += - PFTV @ ti.Vector([ dw[i][<span class="number">0</span>] * w[j][<span class="number">1</span>], w[i][<span class="number">0</span>] * dw[j][<span class="number">1</span>]])</span><br></pre></td></tr></table></figure>
<p>结束从粒子到网格后，在网格更新阶段。我们会根据之前的网格力和速度的计算结果更新网格的速度。其中对于处于边界的网格，我们会额外计算边界条件:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> grid_v:</span><br><span class="line">    <span class="keyword">if</span> grid_m[i, j] == <span class="number">0</span>:</span><br><span class="line">      grid_v[i, j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="comment"># 更新网格状态</span></span><br><span class="line">      <span class="comment"># 由网格动量计算速度</span></span><br><span class="line">      grid_v[i, j] = grid_v[i, j] / grid_m[i, j]</span><br><span class="line">      <span class="comment"># advection</span></span><br><span class="line">      grid_v[i, j] += (g + grid_f[i, j] / grid_m[i, j]) * dt </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解决边界条件</span></span><br><span class="line">    <span class="keyword">if</span> i == n_grid - <span class="number">1</span>:</span><br><span class="line">      grid_v[i, j][<span class="number">0</span>] = <span class="built_in">min</span>(grid_v[i, j][<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">      grid_v[i, j][<span class="number">0</span>] = <span class="built_in">max</span>(grid_v[i, j][<span class="number">0</span>], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> j == n_grid - <span class="number">1</span>:</span><br><span class="line">      grid_v[i, j][<span class="number">1</span>] = <span class="built_in">min</span>(grid_v[i, j][<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> j == <span class="number">0</span>:</span><br><span class="line">      grid_v[i, j][<span class="number">1</span>] = <span class="built_in">max</span>(grid_v[i, j][<span class="number">1</span>], <span class="number">0</span>)</span><br><span class="line">      grid_v[i, j][<span class="number">0</span>] *= <span class="number">0.8</span> <span class="comment">#地面摩擦力</span></span><br></pre></td></tr></table></figure>
<p>注意在这步之前<code>grid_v</code> 中存储的是各个网格的动量，而在这步之后，<code>grid_v</code> 存储的是网格真正的速度。</p>
<p>对于质量为0的网格，为了避免除0错误，需手动将其速度设为0。而对于质量极小的网格，由于在后续的计算中其极大的速度会被权重系数$w_{ip}$ 稀释，因此这里没有使用其它模拟算法中常见的将其质量clamp到一个较小值。</p>
<p>最后在网格到粒子阶段，会把各个网格的速度重新映射回粒子。这里权重及其梯度的算法和前文一致，不再赘述。最后根据公式(e.3),(e.5),(e.6)更新粒子的$F_p$ 值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(n_particles):</span><br><span class="line">   x_p = x[p]</span><br><span class="line"></span><br><span class="line">   x_i_m_1 = (x_p * inv_dx + <span class="number">0.5</span>).cast(<span class="built_in">int</span>) - <span class="number">1</span></span><br><span class="line">   fx = x_p * inv_dx - x_i_m_1.cast(<span class="built_in">float</span>) </span><br><span class="line"></span><br><span class="line">   w = [<span class="number">0.5</span> * (<span class="number">1.5</span> -  fx) ** <span class="number">2</span>, <span class="number">0.75</span> - (fx - <span class="number">1</span>) ** <span class="number">2</span>, <span class="number">0.5</span> * (fx - <span class="number">0.5</span>) ** <span class="number">2</span>]</span><br><span class="line">   dw = [(fx - <span class="number">1.5</span>) * inv_dx, (<span class="number">2.0</span> - <span class="number">2.0</span> * fx) * inv_dx, (fx - <span class="number">0.5</span>) * inv_dx] </span><br><span class="line"></span><br><span class="line">   F_p = F[p]</span><br><span class="line">   new_F_p = F_p</span><br><span class="line">   new_v_p = ti.Vector([<span class="number">0</span>, <span class="number">0</span>], dt=<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> i,j <span class="keyword">in</span> ti.static(ti.ndrange(<span class="number">3</span>, <span class="number">3</span>)):</span><br><span class="line">   <span class="comment">#更新网格的p值</span></span><br><span class="line">     grad_w_ip = ti.Vector([ dw[i][<span class="number">0</span>] * w[j][<span class="number">1</span>], w[i][<span class="number">0</span>] * dw[j][<span class="number">1</span>]])</span><br><span class="line">     w_ip = w[i][<span class="number">0</span>] * w[j][<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">     grid_idx = get_grid_idx(x_i_m_1, i, j)</span><br><span class="line">     </span><br><span class="line">     v_i = grid_v[grid_idx]</span><br><span class="line">     new_F_p += dt *  v_i.outer_product(grad_w_ip) @ F_p</span><br><span class="line">     new_v_p += w_ip * v_i</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   F[p] = new_F_p</span><br><span class="line">   v[p] = new_v_p</span><br><span class="line">   x[p] += new_v_p * dt</span><br></pre></td></tr></table></figure>
<p>代码的运行结果如图所示:</p>
<p><img src="/images/phy1/mpm3.gif" alt=""></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">tzn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/12/07/mpm01/">http://example.com/2023/12/07/mpm01/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">tzn的小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/physics/">physics</a></div><div class="post_share"><div class="social-share" data-image="/images/16801.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/12/05/debugPrintfExt/" title="如何在glsl中使用printf--debugPrintfExt"><img class="cover" src="/images/otto0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">如何在glsl中使用printf--debugPrintfExt</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/12/05/CS417-physics-based-animation%E7%AC%94%E8%AE%B0/" title="CS417 physics based animation笔记"><img class="cover" src="/images/newton0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-05</div><div class="title">CS417 physics based animation笔记</div></div></a></div><div><a href="/2023/12/05/Smoothed-particle-hydrodynamics/" title="Smoothed-particle hydrodynamics"><img class="cover" src="/images/ia0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-05</div><div class="title">Smoothed-particle hydrodynamics</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/ranran0.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">tzn</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tzn893"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">tzn的笔记杂物间, 以后可能会写点有杂谈发电在这里捏</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Push-Forward-and-Pull-Back"><span class="toc-number">1.</span> <span class="toc-text">Push Forward and Pull Back</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E8%A7%86%E8%A7%92%E5%92%8C%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E8%A7%86%E8%A7%92"><span class="toc-number">2.</span> <span class="toc-text">欧拉视角和拉格朗日视角</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%AF%E5%88%86%E5%8F%98%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">积分变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E5%8A%9B%E5%9C%BA"><span class="toc-number">4.</span> <span class="toc-text">压力场</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A1%91%E6%80%A7%E5%BD%A2%E5%8F%98"><span class="toc-number">5.</span> <span class="toc-text">塑性形变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%96%B9%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">控制方程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E7%A8%8B%E7%9A%84%E5%BC%B1%E8%A7%A3"><span class="toc-number">7.</span> <span class="toc-text">方程的弱解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E8%B4%A8%E7%82%B9"><span class="toc-number">8.</span> <span class="toc-text">物质点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">时间离散化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">空间离散化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%BD%A2%E5%8F%98%E6%A2%AF%E5%BA%A6"><span class="toc-number">11.</span> <span class="toc-text">计算形变梯度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BD%9C%E5%9C%A8%E8%83%BD%E9%87%8F%E5%92%8C%E5%8F%97%E5%8A%9B"><span class="toc-number">12.</span> <span class="toc-text">潜在能量和受力</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%AC%A7%E6%8B%89"><span class="toc-number"></span> <span class="toc-text">显式前向欧拉</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#APIC"><span class="toc-number">1.</span> <span class="toc-text">APIC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%BD%A2%E5%8F%98%E6%A2%AF%E5%BA%A6"><span class="toc-number">2.</span> <span class="toc-text">更新形变梯度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%8F%97%E5%8A%9B"><span class="toc-number">3.</span> <span class="toc-text">计算受力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.</span> <span class="toc-text">完整步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">5.</span> <span class="toc-text">代码解读</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/12/07/mpm01/" title="物质质点法--从理论到实现"><img src="/images/16801.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="物质质点法--从理论到实现"/></a><div class="content"><a class="title" href="/2023/12/07/mpm01/" title="物质质点法--从理论到实现">物质质点法--从理论到实现</a><time datetime="2023-12-06T16:44:02.000Z" title="发表于 2023-12-07 00:44:02">2023-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/debugPrintfExt/" title="如何在glsl中使用printf--debugPrintfExt"><img src="/images/otto0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何在glsl中使用printf--debugPrintfExt"/></a><div class="content"><a class="title" href="/2023/12/05/debugPrintfExt/" title="如何在glsl中使用printf--debugPrintfExt">如何在glsl中使用printf--debugPrintfExt</a><time datetime="2023-12-05T07:43:07.000Z" title="发表于 2023-12-05 15:43:07">2023-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/vkrt/" title="vulkan 光线追踪"><img src="/images/miku0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vulkan 光线追踪"/></a><div class="content"><a class="title" href="/2023/12/05/vkrt/" title="vulkan 光线追踪">vulkan 光线追踪</a><time datetime="2023-12-05T07:40:26.000Z" title="发表于 2023-12-05 15:40:26">2023-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/Smoothed-particle-hydrodynamics/" title="Smoothed-particle hydrodynamics"><img src="/images/ia0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Smoothed-particle hydrodynamics"/></a><div class="content"><a class="title" href="/2023/12/05/Smoothed-particle-hydrodynamics/" title="Smoothed-particle hydrodynamics">Smoothed-particle hydrodynamics</a><time datetime="2023-12-05T03:44:40.000Z" title="发表于 2023-12-05 11:44:40">2023-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/CS417-physics-based-animation%E7%AC%94%E8%AE%B0/" title="CS417 physics based animation笔记"><img src="/images/newton0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CS417 physics based animation笔记"/></a><div class="content"><a class="title" href="/2023/12/05/CS417-physics-based-animation%E7%AC%94%E8%AE%B0/" title="CS417 physics based animation笔记">CS417 physics based animation笔记</a><time datetime="2023-12-05T02:58:49.000Z" title="发表于 2023-12-05 10:58:49">2023-12-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By tzn</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>