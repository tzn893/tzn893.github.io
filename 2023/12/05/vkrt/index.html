<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>vulkan 光线追踪 | tzn的小窝</title><meta name="author" content="tzn"><meta name="copyright" content="tzn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1.准备部分需要添加的device   extension:VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME,VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME以及 VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME在创建device的过程中，需要将其加到 VkDeviceCreat">
<meta property="og:type" content="article">
<meta property="og:title" content="vulkan 光线追踪">
<meta property="og:url" content="http://example.com/2023/12/05/vkrt/index.html">
<meta property="og:site_name" content="tzn的小窝">
<meta property="og:description" content="1.准备部分需要添加的device   extension:VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME,VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME以及 VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME在创建device的过程中，需要将其加到 VkDeviceCreat">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/miku0.jpg">
<meta property="article:published_time" content="2023-12-05T07:40:26.000Z">
<meta property="article:modified_time" content="2023-12-05T09:44:36.278Z">
<meta property="article:author" content="tzn">
<meta property="article:tag" content="vulkan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/miku0.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/12/05/vkrt/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'vulkan 光线追踪',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-05 17:44:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/ranran0.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/miku0.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="tzn的小窝"><span class="site-name">tzn的小窝</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">vulkan 光线追踪</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-05T07:40:26.000Z" title="发表于 2023-12-05 15:40:26">2023-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-05T09:44:36.278Z" title="更新于 2023-12-05 17:44:36">2023-12-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="vulkan 光线追踪"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h4 id="1-准备部分"><a href="#1-准备部分" class="headerlink" title="1.准备部分"></a>1.准备部分</h4><p>需要添加的device   extension:<code>VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME</code>,<code>VK_KHR_RAY_TRACING_PIPELINE_EXTENSION_NAME</code>以及 <code>VK_KHR_DEFERRED_HOST_OPERATIONS_EXTENSION_NAME</code>在创建device的过程中，需要将其加到 <code>VkDeviceCreateInfo</code> 结构体的 ppEnabledExtensionNames 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; usedExtensions;</span><br><span class="line">...<span class="comment">//添加其它extension</span></span><br><span class="line">usedExtensions.<span class="built_in">push_back</span>();</span><br><span class="line">...</span><br><span class="line">VkDeviceCreateInfo createInfo&#123;&#125;;</span><br><span class="line">createInfo.ppEnabledExtensionNames = usedExtensions.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>
<p>之后，我们可以通过<code>VkPhysicalDeviceRayTracingPipelinePropertiesKHR</code> 结构体取得vulkan ray tracing一些属性。具体方法为，将 <code>VkPhysicalDeviceRayTracingPipelinePropertiesKHR</code> 绑定到 <code>VkPhysicalDeviceProperties2</code> 的pNext上通过 <code>vkGetPhysicalDeviceProperties2</code> 取得。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkPhysicalDevice physicalDevice;<span class="comment">//已经创建好的physical device</span></span><br><span class="line">VkPhysicalDeviceRayTracingPipelinePropertiesKHR rayTracingProp&#123;</span><br><span class="line">	VK_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR</span><br><span class="line">&#125;;<span class="comment">//需要获取的光追参数</span></span><br><span class="line">VkPhysicalDeviceProperties2 prop2&#123;VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2&#125;;</span><br><span class="line">prop2.pNext = &amp;rayTracingProp;</span><br><span class="line"><span class="built_in">vkGetPhysicalDeviceProperties2</span>(physicalDevice,&amp;prop2);</span><br></pre></td></tr></table></figure>
<h4 id="2-加速结构acceleration-structure"><a href="#2-加速结构acceleration-structure" class="headerlink" title="2.加速结构acceleration structure"></a>2.加速结构acceleration structure</h4><p>在用户视角下，加速结构分为两层:全局只有一个的TLAS和装载着具体数据的BLAS:</p>
<p>BLAS包含了模型的顶点数据，它可以由多个vertex buffer构建，每个vertex buffer可以携带一个transform matrix信息来表示其在这个BLAS的位置偏移。</p>
<p>每个TLAS包含了多个instance数据，每个instance含有一个transform matrix并引用一个BLAS数据</p>
<p><img src="/images/vk/vkrt.2.1.png" alt="as"></p>
<h5 id="2-1-Bottom-Level-Acceleration-Structure"><a href="#2-1-Bottom-Level-Acceleration-Structure" class="headerlink" title="2.1 Bottom Level Acceleration Structure"></a>2.1 Bottom Level Acceleration Structure</h5><h6 id="2-1-1-Build-Bottom-Level-Acceleration-Structure"><a href="#2-1-1-Build-Bottom-Level-Acceleration-Structure" class="headerlink" title="2.1.1 Build Bottom Level Acceleration Structure"></a>2.1.1 Build Bottom Level Acceleration Structure</h6><p>Blas由 <code>VkAccelerationStructureKHR</code> 和 <code>VkBuffer</code> 构成，通过调用vkCmdBuildAccelerationStructuresKHR创建。在构建过程中需要初始化一下几个结构体： </p>
<p><code>VkAccelerationStructureGeometryKHR</code>  和<code>VkAccelerationStructureBuildRangeInfoKHR</code> 描述了构建BLAS需要的几何数据的格式，地址，类型等信息。（一个Model下的submesh 对应一个Geometry和BuildRangeInfo）</p>
<p><code>VkAccelerationStructureGeometryKHR</code> 声明如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkAccelerationStructureGeometryKHR</span> &#123;</span><br><span class="line">    VkStructureType                           sType;<span class="comment">//这个数据结构的类型，下同</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                               pNext;<span class="comment">//指向拓展数据结构，方便拓展，下同</span></span><br><span class="line">    VkGeometryTypeKHR                         geometryType;<span class="comment">//几何数据的类型</span></span><br><span class="line">    VkAccelerationStructureGeometryDataKHR    geometry;<span class="comment">//描述了几类几何数据的union</span></span><br><span class="line">    VkGeometryFlagsKHR                        flags;</span><br><span class="line">&#125; VkAccelerationStructureGeometryKHR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">VkAccelerationStructureGeometryDataKHR</span> &#123;</span><br><span class="line">    VkAccelerationStructureGeometryTrianglesDataKHR    triangles;</span><br><span class="line">    VkAccelerationStructureGeometryAabbsDataKHR        aabbs;</span><br><span class="line">    VkAccelerationStructureGeometryInstancesDataKHR    instances;</span><br><span class="line">&#125; VkAccelerationStructureGeometryDataKHR;</span><br></pre></td></tr></table></figure>
<p>对于最常见的三角网格，其类型为 <code>VK_GEOMETRY_TYPE_TRIANGLES_KHR</code> ，与其对应的geometry为 <code>VkAccelerationStructureGeometryTrianglesDataKHR</code> </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkAccelerationStructureGeometryTrianglesDataKHR</span> &#123;</span><br><span class="line">    VkStructureType                  sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                      pNext;</span><br><span class="line">    VkFormat                         vertexFormat;<span class="comment">//顶点position数据的格式</span></span><br><span class="line">    VkDeviceOrHostAddressConstKHR    vertexData;<span class="comment">//指向顶点数据的指针（要以position数据开头）</span></span><br><span class="line">    VkDeviceSize                     vertexStride;<span class="comment">//每个顶点数据的偏移量</span></span><br><span class="line">    <span class="type">uint32_t</span>                         maxVertex;<span class="comment">//最多顶点数</span></span><br><span class="line">    VkIndexType                      indexType;<span class="comment">//index数据的类型</span></span><br><span class="line">    VkDeviceOrHostAddressConstKHR    indexData;<span class="comment">//指向index数据的指针</span></span><br><span class="line">    VkDeviceOrHostAddressConstKHR    transformData;</span><br><span class="line">&#125; VkAccelerationStructureGeometryTrianglesDataKHR;</span><br></pre></td></tr></table></figure>
<p>需要注意的是这里并不需要像Vertex Attributes一样把每个vertex的所有信息描述一遍，而只需要填写vertex的position数据对应的位置即可。这里的vertexData和indexData关联的buffer均需要在创建的时候设置flag  <code>VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR.</code>  否则vulkan debug layer会报错：</p>
<p><img src="/images/vk/vkrt.2.2.png" alt=""></p>
<p><code>VkAccelerationStructureBuildRangeInfoKHR</code> 的作用类似index buffer,其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkAccelerationStructureBuildRangeInfoKHR</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>    primitiveCount;</span><br><span class="line">    <span class="type">uint32_t</span>    primitiveOffset;</span><br><span class="line">    <span class="type">uint32_t</span>    firstVertex;</span><br><span class="line">    <span class="type">uint32_t</span>    transformOffset;</span><br><span class="line">&#125; VkAccelerationStructureBuildRangeInfoKHR;</span><br></pre></td></tr></table></figure>
<p>其transformOffset和 <code>VkAccelerationStructureGeometryTrianglesDataKHR</code> 中的 transformData 一起，描述了一个triangle的transform信息。官方文档对其有如下解释：</p>
<ul>
<li>If <a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryTrianglesDataKHR.html">VkAccelerationStructureGeometryTrianglesDataKHR</a>::<code>transformData</code> is not <code>NULL</code>, a single <a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkTransformMatrixKHR.html">VkTransformMatrixKHR</a> structure is consusmed from <a target="_blank" rel="noopener" href="https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureGeometryTrianglesDataKHR.html">VkAccelerationStructureGeometryTrianglesDataKHR</a>::<code>transformData</code>, at an offset of <code>transformOffset</code>. This matrix describes a transformation from the space in which the vertices for all triangles in this geometry are described to the space in which the acceleration structure is defined.</li>
</ul>
<p>填写好模型的描述信息后，我们可以开始着手构建acceleration structure。</p>
<p>对于每个BlAS,我们在构建时需要一个对应的 <code>VkAccelerationStructureBuildGeometryInfoKHR</code>,<code>VkAccelerationStructureBuildSizesInfoKHR</code> 以及对应的一系列<code>VkAccelerationStructureBuildRangeInfoKHR</code> （每个submesh一个）。</p>
<p><code>VkAccelerationStructureBuildGeometryInfoKHR</code> 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkAccelerationStructureBuildGeometryInfoKHR</span> &#123;</span><br><span class="line">    VkStructureType                                     sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                                         pNext;</span><br><span class="line">    VkAccelerationStructureTypeKHR                      type;<span class="comment">//被构建的acceleration structure的类型(BLAS或TLAS)</span></span><br><span class="line">    VkBuildAccelerationStructureFlagsKHR                flags;<span class="comment">//一些调整build过程的flag</span></span><br><span class="line">    VkBuildAccelerationStructureModeKHR                 mode;<span class="comment">//build的模式（更新或完全重建）</span></span><br><span class="line">    VkAccelerationStructureKHR                          srcAccelerationStructure;<span class="comment">//更新时的源AS</span></span><br><span class="line">    VkAccelerationStructureKHR                          dstAccelerationStructure;<span class="comment">//输出AS</span></span><br><span class="line">    <span class="type">uint32_t</span>                                            geometryCount;<span class="comment">//几何数据的数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//具体数据，具体细节可以看官网https://registry.khronos.org/vulkan/specs/1.3-extensions/man/html/VkAccelerationStructureBuildGeometryInfoKHR.html</span></span><br><span class="line">    <span class="type">const</span> VkAccelerationStructureGeometryKHR*           pGeometries;</span><br><span class="line">    <span class="type">const</span> VkAccelerationStructureGeometryKHR* <span class="type">const</span>*    ppGeometries;</span><br><span class="line">    VkDeviceOrHostAddressKHR                            scratchData;</span><br><span class="line">&#125; VkAccelerationStructureBuildGeometryInfoKHR;</span><br></pre></td></tr></table></figure>
<p><code>VkAccelerationStructureBuildSizesInfoKHR</code>  定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provided by VK_KHR_acceleration_structure</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkAccelerationStructureBuildSizesInfoKHR</span> &#123;</span><br><span class="line">    VkStructureType    sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*        pNext;</span><br><span class="line">    VkDeviceSize       accelerationStructureSize;<span class="comment">//dstAccelerationStructure关联的buffer的size</span></span><br><span class="line">    VkDeviceSize       updateScratchSize;<span class="comment">//update操作需要的scratch buffer大小</span></span><br><span class="line">    VkDeviceSize       buildScratchSize;<span class="comment">//build操作需要的scratch buffer大小</span></span><br><span class="line">&#125; VkAccelerationStructureBuildSizesInfoKHR;</span><br></pre></td></tr></table></figure>
<p>scratch buffer是什么官方文档没有明确的解释，我个人认为它是用来存放build过程中产生数据的临时buffer需要在build之前构建并在build之后释放。在创建scratch buffer时至少需要两个flag:<code>VK_BUFFER_USAGE_STORAGE_BUFFER_BIT</code> (<a target="_blank" rel="noopener" href="https://vulkan.lunarg.com/doc/view/1.3.216.0/windows/1.3-extensions/vkspec.html#VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03674)和`VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT`">https://vulkan.lunarg.com/doc/view/1.3.216.0/windows/1.3-extensions/vkspec.html#VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03674)和`VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT`</a> (为了获取device address)。</p>
<p><code>VkAccelerationStructureBuildSizesInfoKHR</code> 的信息可以通过vkGetAccelerationStructureBuildSizesKHR 获取。</p>
<p>总的来说，构建Blas的流程如下(下面的代码中(A,B)代表A,B组成的元组)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;(vector&lt;VkAccelerationStructureGeometryKHR&gt;,vector&lt;VkAccelerationStructureBuildRangeInfoKHR&gt;)&gt;      geometies;</span><br><span class="line">...<span class="comment">//遍历场景中模型数据获得geometry和build range信息(一个vector&lt;VkAccelerationStructureGeometryKHR&gt;对应一个Blas)</span></span><br><span class="line"><span class="type">uint32_t</span> nBlas = geometries.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">vector&lt;(VkAccelerationStructureBuildGeometryInfoKHR,VkAccelerationStructureBuildSizesInfoKHR)&gt; buildInfos;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nBlas;i++)&#123;</span><br><span class="line">    VkAccelerationStructureBuildGeometryInfoKHR  buildInfo;</span><br><span class="line">    ...<span class="comment">//填写buildInfo</span></span><br><span class="line">    buildGeometryInfos.<span class="built_in">push_back</span>(buildInfo);</span><br><span class="line">    VkAccelerationStructureBuildSizesInfoKHR sizeInfo;</span><br><span class="line">    <span class="built_in">vkGetAccelerationStructureBuildSizesKHR</span>(...);<span class="comment">//获取sizeInfo</span></span><br><span class="line">    buildInfos.<span class="built_in">push_back</span>((buildInfo,sizeInfo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Buffer scratchBuffer = <span class="built_in">createBuffer</span>(...);<span class="comment">//根据build size info中scratch buffer的最大值创建一个所有blas共用的scratch buffer(Buffer是指封装了VkBuffer和VkMemory的buffer)</span></span><br><span class="line"></span><br><span class="line">vector&lt;(VkAccelerationStructureKHR,Buffer)&gt; blases;</span><br><span class="line"><span class="comment">//实际实现时可以分批进行，避免太频繁的submit</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nBlas;i++)&#123;</span><br><span class="line">    VkCommandBuffer cmdBuffer;<span class="comment">//从command pool中分配一个command buffer用来记录</span></span><br><span class="line">    Buffer buffer = <span class="built_in">createBuffer</span>(...);<span class="comment">//根据build size info的buffer size创建buffer</span></span><br><span class="line">    VkAccelerationStructureCreateInfoKHR createInfo;</span><br><span class="line">    VkAccelerationStructureKHR as;</span><br><span class="line">    ...<span class="comment">//填写createInfo,type为VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR</span></span><br><span class="line">    <span class="built_in">vkCreateAccelerationStructureKHR</span>(device,&amp;createInfo,<span class="literal">nullptr</span>,&amp;as);<span class="comment">//创建acceleration structure</span></span><br><span class="line">    buildInfos[i]<span class="number">.0</span>.dstAccelerationStructure = as;<span class="comment">//输出as</span></span><br><span class="line">    buildInfos[i]<span class="number">.0</span>.scratchData.deviceAddress = <span class="built_in">getDeviceAddress</span>(scratchBuffer);<span class="comment">//需要的scratch buffer</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vkCmdBuildAccelerationStructuresKHR</span>(cmdBuffer,<span class="number">1</span>,&amp;buildInfos[i]<span class="number">.0</span>,&amp;geometies[i]<span class="number">.1</span>.<span class="built_in">data</span>());</span><br><span class="line">    ...<span class="comment">//一些buffer需要memory barrier操作</span></span><br><span class="line">    <span class="built_in">submit</span>(cmdBuffer);<span class="comment">//将command buffer送到command queue以执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-1-2-Build-Compacted-Bottom-Level-Acceleration-Structure"><a href="#2-1-2-Build-Compacted-Bottom-Level-Acceleration-Structure" class="headerlink" title="2.1.2 Build Compacted Bottom Level Acceleration Structure"></a>2.1.2 Build Compacted Bottom Level Acceleration Structure</h6><p>除上述方法之外我们还可以构建一种数据组织的更紧凑的BLAS。（TODO）</p>
<h5 id="2-2-Build-Top-Level-Acceleration-Structure"><a href="#2-2-Build-Top-Level-Acceleration-Structure" class="headerlink" title="2.2 Build Top Level Acceleration Structure"></a>2.2 Build Top Level Acceleration Structure</h5><p>与Blas相同一个Tlas由<code>VkAccelerationStructureKHR</code> 和 <code>VkBuffer</code> 构成，通过调用vkCmdBuildAccelerationStructuresKHR构建。</p>
<p>构建Tlas同样需要通过<code>VkAccelerationStructureBuildGeometryInfoKHR</code> 描述几何信息。与Blas不同的是，一个Tlas只有一个geometry （<code>geometryCount</code> 为1）— <code>VkAccelerationStructureGeometryInstancesDataKHR</code> 。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkAccelerationStructureGeometryInstancesDataKHR</span> &#123;</span><br><span class="line">    VkStructureType                  sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                      pNext;</span><br><span class="line">    VkBool32                         arrayOfPointers;</span><br><span class="line">    VkDeviceOrHostAddressConstKHR    data;</span><br><span class="line">&#125; VkAccelerationStructureGeometryInstancesDataKHR;</span><br></pre></td></tr></table></figure>
<p>其中data为指向该Tlas下所有instance的buffer的指针。每个instance由一个<code>VkAccelerationStructureInstanceKHR</code> 描述：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkAccelerationStructureInstanceKHR</span> &#123;</span><br><span class="line">    VkTransformMatrixKHR          transform;<span class="comment">//这个instance的transform的矩阵</span></span><br><span class="line">    <span class="type">uint32_t</span>                      instanceCustomIndex:<span class="number">24</span>;<span class="comment">//instance的index</span></span><br><span class="line">    <span class="type">uint32_t</span>                      mask:<span class="number">8</span>;<span class="comment">//求交时 ray.mask &amp; instance.mask != 0 时才会相交</span></span><br><span class="line">    <span class="type">uint32_t</span>                      instanceShaderBindingTableRecordOffset:<span class="number">24</span>;</span><br><span class="line">    VkGeometryInstanceFlagsKHR    flags:<span class="number">8</span>;</span><br><span class="line">    <span class="type">uint64_t</span>                      accelerationStructureReference;<span class="comment">//这个instance的mesh在blas中的index</span></span><br><span class="line">&#125; VkAccelerationStructureInstanceKHR;</span><br></pre></td></tr></table></figure>
<p>同时，对于Tlas一个instance为一个primitive,因此<code>VkAccelerationStructureBuildRangeInfoKHR</code> 中<code>primitiveCount</code>  为 instance数量，其余值为0。</p>
<p>其余部分，Tlas和Blas几乎相同，可以参照构建Blas的代码实现。</p>
<h4 id="3-Ray-Tracing-Pipeline"><a href="#3-Ray-Tracing-Pipeline" class="headerlink" title="3.Ray Tracing Pipeline"></a>3.Ray Tracing Pipeline</h4><p>一个ray tracing pipeline 如下图所示：</p>
<p><img src="/images/vk/vkrt.3.1.png" alt=""></p>
<p>总的来说，rt pipeline一共有5类shader</p>
<ol>
<li>ray generation shader:对render target上每个pixel调用。整个光追流程的入口，通过该shader生成光线，向render target写入颜色。</li>
<li>intersection shader: 主要用来与用户自定义的非三角网格几何体做相交测试（如隐式描述的几何体表面）</li>
<li>any hit shader:一个ray的intersection可能有很多结果，由这个shader从这些结果中挑选出一个返回给cloest hit shader。对于内置的any hit shader，会返回离ray出发点最近的相交点。</li>
<li>Miss shader:当ray没有击中场景时执行</li>
<li>Closest Hit Shader:当ray击中场景时执行</li>
</ol>
<h5 id="3-1-Create-Ray-Tracing-Pipeline-and-Shader-Binding-Table"><a href="#3-1-Create-Ray-Tracing-Pipeline-and-Shader-Binding-Table" class="headerlink" title="3.1 Create Ray Tracing Pipeline and Shader Binding Table"></a>3.1 Create Ray Tracing Pipeline and Shader Binding Table</h5><p>在ray tracing中shader不再是像光栅化管线一样一个阶段一个shader的执行，而是所有shader放在一起形成一个shader binding table(SBT)，再在每次<code>traceRayExt</code>中根据相交测试的结果从SBT中选择相应的shader执行。</p>
<p>在创建SBT之前，需要创建ray tracing pipeline，<code>VkRayTracingPipelineCreateInfoKHR</code> 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkRayTracingPipelineCreateInfoKHR</span> &#123;</span><br><span class="line">    VkStructureType                                      sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                                          pNext;</span><br><span class="line">    VkPipelineCreateFlags                                flags;</span><br><span class="line">    <span class="type">uint32_t</span>                                             stageCount;<span class="comment">//shader stage的数量</span></span><br><span class="line">    <span class="type">const</span> VkPipelineShaderStageCreateInfo*               pStages;<span class="comment">//shader stage的指针</span></span><br><span class="line">    <span class="type">uint32_t</span>                                             groupCount;<span class="comment">//shader group数量</span></span><br><span class="line">    <span class="type">const</span> VkRayTracingShaderGroupCreateInfoKHR*          pGroups;<span class="comment">//shader group的指针</span></span><br><span class="line">    <span class="type">uint32_t</span>                                             maxPipelineRayRecursionDepth;<span class="comment">//最大递归深度</span></span><br><span class="line">    <span class="type">const</span> VkPipelineLibraryCreateInfoKHR*                pLibraryInfo;</span><br><span class="line">    <span class="type">const</span> VkRayTracingPipelineInterfaceCreateInfoKHR*    pLibraryInterface;</span><br><span class="line">    <span class="type">const</span> VkPipelineDynamicStateCreateInfo*              pDynamicState;</span><br><span class="line">    VkPipelineLayout                                     layout;<span class="comment">//pipeline对应的layout</span></span><br><span class="line">    VkPipeline                                           basePipelineHandle;</span><br><span class="line">    <span class="type">int32_t</span>                                              basePipelineIndex;</span><br><span class="line">&#125; VkRayTracingPipelineCreateInfoKHR;</span><br></pre></td></tr></table></figure>
<p>其中，除了sType没带注释的成员是选填的，我们也会重关注这些部分。</p>
<p>与graphics pipeline相同，我们需要为ray trace pipeline中每一个shader创建一个<code>VkPipelineShaderStageCreateInfo</code>。同时，我们还需要为这些shader创建Shader Group，<code>VkRayTracingShaderGroupCreateInfoKHR</code> 的定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VkRayTracingShaderGroupCreateInfoKHR</span> &#123;</span><br><span class="line">    VkStructureType                   sType;</span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                       pNext;</span><br><span class="line">    VkRayTracingShaderGroupTypeKHR    type;</span><br><span class="line">    <span class="type">uint32_t</span>                          generalShader;<span class="comment">//general shader在pStages中的index</span></span><br><span class="line">    <span class="type">uint32_t</span>                          closestHitShader;<span class="comment">//closest hit shader在pStages中的index</span></span><br><span class="line">    <span class="type">uint32_t</span>                          anyHitShader;<span class="comment">//any hit shader在pStages中的index</span></span><br><span class="line">    <span class="type">uint32_t</span>                          intersectionShader;<span class="comment">//intersection shader在pStages中的index</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span>*                       pShaderGroupCaptureReplayHandle;</span><br><span class="line">&#125; VkRayTracingShaderGroupCreateInfoKHR;</span><br></pre></td></tr></table></figure>
<p>在相交测试过程中，intersection shader，any hit shader和closest hit shader三个shader是紧密关联在一起的，它们会打包成一个shader group并形成一个handle（如对一个不透明球光线追踪，需要一个intersection shader和closest hit shader，它们可以打包成一个shader group并在shader代码中用一个handle引用）。而其它类型的shader(如ray generation和miss)则都是general shader，它们一个shader对应一个shader group。</p>
<p>在填写好<code>VkRayTracingPipelineCreateInfoKHR</code>后我们可以通过<code>vkCreateRayTracingPipelinesKHR</code> 创建ray tracing pipeline。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkCreateRayTracingPipelinesKHR</span>(device,&#123;&#125;,&#123;&#125;,<span class="number">1</span>,&amp;rtCreateInfo,<span class="literal">nullptr</span>,&amp;rtPipeline);</span><br></pre></td></tr></table></figure>
<p>在创建好shader stage，shader group以及ray tracing pipeline后，我们可以开始创建shader binding table。shader binding table就是一个装了若干shader group handle的buffer,在shader 代码中通过index来查找。vulkan对SBT的aligment有要求，这些信息可以在<code>VkPhysicalDeviceRayTracingPipelinePropertiesKHR</code> 中获取。一个shader binding table的内存分布如下图所示：</p>
<p><img src="/images/vk/vkrt.4.1.png" alt=""></p>
<p>在SBT创建的过程中我们需要<code>VkPhysicalDeviceRayTracingPipelinePropertiesKHR</code> 中的三种信息：</p>
<ol>
<li><code>shaderGroupHandleSize</code>，每个shader group handle的大小。</li>
<li><code>shaderGroupHandleAlignment</code> 在SBT中每个shader group handle的stride都需要一个alignment因此每个shader group handle的stride大小为</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prop为VkPhysicalDeviceRayTracingPipelinePropertiesKHR</span></span><br><span class="line">handleStride = <span class="built_in">align_up</span>(prop.shaderGroupHandleSize,prop.shaderGroupHandleAlignment);</span><br></pre></td></tr></table></figure>
<p>   3.<code>shaderGroupBaseAlignment</code> 每个SBT会根据不同的shader group类型(ray gen,hit,miss,callable)分为各个区域(上图中不同颜色标注的区域)，而每个区域之间需要有alignment。因此，每个区域之间的stride为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prop为VkPhysicalDeviceRayTracingPipelinePropertiesKHR</span></span><br><span class="line"><span class="comment">//regionHandleCount为该区域中shader group handle的数量</span></span><br><span class="line">regionStride = <span class="built_in">align_up</span>(handleStride * regionHandleCount,prop.shaderGroupBaseAlignment);</span><br></pre></td></tr></table></figure>
<p>总的来说，创建sbt的伪代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sbt内存布局</span></span><br><span class="line">uint32 rayGenRegionStart  ,rayGenStride  ,rayGenSize;</span><br><span class="line">uint32 hitRegionStart     ,hitStride     ,hitSize;</span><br><span class="line">uint32 missRegionStart    ,missStride    ,missSize;</span><br><span class="line">uint32 callableRegionStart,callableStride,callableSize;</span><br><span class="line"><span class="comment">//关于callable shader可以看https://www.reddit.com/r/vulkan/comments/gtqrym/use_case_for_callable_shaders</span></span><br><span class="line"><span class="built_in">calculateMemoryRegions</span>();<span class="comment">//计算各个区域的内存布局</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt; <span class="title">shaderGroupHandles</span><span class="params">(handleCount * handleSize)</span></span>;</span><br><span class="line"><span class="built_in">vkGetRayTracingShaderGroupHandlesKHR</span>(device,rtPipeline,<span class="number">0</span>,shaderGroupHandles.<span class="built_in">data</span>(),shaderGroupHandles.<span class="built_in">size</span>());<span class="comment">//获取rtPipeline中的shader group handle数据。shader group handle的顺序和VkRayTracingShaderGroupCreateInfoKHR 中pGroups的顺序相同。</span></span><br><span class="line"></span><br><span class="line">Buffer SBT = <span class="built_in">createBuffer</span>(...);<span class="comment">//创建buffer，需要flag VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR</span></span><br><span class="line"><span class="type">void</span>* sbtData = SBT.<span class="built_in">map</span>(...);<span class="comment">//将buffer 内存map到cpu</span></span><br><span class="line"><span class="built_in">copyShaderGroupData</span>();<span class="comment">//将shaderGroupHandles中数据复制到stbData中</span></span><br></pre></td></tr></table></figure>
<h5 id="3-2-Ray-Trace-Command"><a href="#3-2-Ray-Trace-Command" class="headerlink" title="3.2 Ray Trace Command"></a>3.2 Ray Trace Command</h5><p>与光栅化管线不同，光追并不需要render pass。可以在<code>vkAcquireNextImageKHR</code> 之后直接开始渲染。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vkAcquireNextImageKHR</span>(...);<span class="comment">//acquire下一帧</span></span><br><span class="line"><span class="keyword">auto</span> cmdBuf = <span class="built_in">getCommandBuffer</span>(...);<span class="comment">//获取当前帧的command buffer</span></span><br><span class="line"><span class="built_in">rayTrace</span>(cmdBuf);<span class="comment">//记录光追命令</span></span><br></pre></td></tr></table></figure>
<p>在<code>rayTrace</code>中我们需要通过调用<code>vkCmdTraceRaysKHR</code>进行光追。<code>vkCmdTraceRaysKHR</code> 需要sbt各个region的deviceaddress。我们可以通过3.1中sbt的内存布局计算得到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VkStridedDeviceAddressRegionKHR hitRegion,missRegion,rayGenRegion,callableRegion;</span><br><span class="line">VkDeviceAddress sbtAddress;<span class="comment">//通过vkGetBufferDeviceAddress获得</span></span><br><span class="line"></span><br><span class="line">hitRegion.stride = hitStride,hitRegion.deviceAddress = sbtAddress + hitRegionStart,hitRegion.size = hitSize;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="built_in">vkCmdTraceRaysKHR</span>(cmdBuf,&amp;rayGenRegion,&amp;missRegion,&amp;hitRegion,&amp;callRegion,screenWidth,screenHeight,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="4-Ray-Tracing-GLSL"><a href="#4-Ray-Tracing-GLSL" class="headerlink" title="4.Ray Tracing GLSL"></a>4.Ray Tracing GLSL</h4><p>首先在最开始需要开启glsl的光追模块</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#extension GL_EXT_ray_tracing : require</span></span><br></pre></td></tr></table></figure>
<p>在ray tracing 中通过调用<code>traceRayExt</code> 生成光线，而光线击中场景后又会去调用相应的shader。这样两个shader之间形成了类似调用和被调用的关系。调用者和被调用者之间通过pay load交换数据。调用者可以声明多个<code>rayPayloadEXT</code> (一个location一个pay load),并在<code>traceRayExt</code> 中让一个<code>rayPayloadExt</code>可见，在被调用者中声明<code>rayPayloadInEXT</code> 来接收这个数据。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//caller</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) traceRayExt <span class="type">bool</span> payload;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    traceRayExt(</span><br><span class="line">    	...,</span><br><span class="line">        <span class="number">0</span> <span class="comment">//在location 0的pay load对下一个shader可见</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//现在payload = false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//caller end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//callee</span></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) rayPayloadInEXT <span class="type">bool</span> payload;</span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="comment">//在callee中可以通过payload与caller交换数据</span></span><br><span class="line">    payload = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//callee end</span></span><br></pre></td></tr></table></figure>
<p><code>traceRayExt</code> 的参数如下（具体可以看<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_tracing.txt）(之后的讨论围绕$ray=dir">https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_tracing.txt）(之后的讨论围绕$ray=dir</a> * t + origin$ 展开)</p>
<ul>
<li><code>tlas : accelerationStructureEXT</code>  需要trace的场景的tlas</li>
<li><code>flags</code> trace过程中的flag如<code>gl_RayFlagsSkipClosestHitShaderEXT</code>(跳过closest hit shader), <code>gl_RayFlagsTerminateOnFirstHitEXT</code>(在第一次击中就结束)等。</li>
<li><code>mask : uint8</code> 光线的mask和tlas中的mask(见2.2)对应。当光线的mask能覆盖instance的mask时光线才能击中。</li>
<li><code>sbtRecordOffset : uint</code> hit shader的offset</li>
<li><code>sbtRecordStride : uint</code> hit shader的stride。和offset一起决定hit的时候选用哪个hit shader。这个过程相当复杂具体可以看<a target="_blank" rel="noopener" href="https://www.willusher.io/graphics/2019/11/20/the-sbt-three-ways">https://www.willusher.io/graphics/2019/11/20/the-sbt-three-ways</a> Hit Group Shader Record Index Calculation 部分</li>
<li><code>origin : vec3</code> ray的出发点</li>
<li><code>minRange : float</code> ray的t的最小值</li>
<li><code>dir : vec3</code>  ray的方向</li>
<li><code>maxRange : float</code> ray的t的最大值</li>
<li><code>payload : const uint</code> payload 的 location </li>
</ul>
<p>除此以外，glsl提供了一些有用的内置值(具体可以看<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_tracing.txt)：">https://github.com/KhronosGroup/GLSL/blob/master/extensions/ext/GLSL_EXT_ray_tracing.txt)：</a></p>
<ul>
<li><p><code>gl_LaunchIDEXT : uint2</code>  当前该shader的pixel id</p>
</li>
<li><p><code>gl_LaunchSizeEXT : uint2</code> vkCmdTraceRaysKHR命令中传入的width和height</p>
</li>
<li><p><code>gl_InstanceCustomIndexEXT : uint</code> 在closest hit shader中，被击中的instance的index</p>
</li>
<li><p><code>gl_PrimitiveID : uint</code> 在closest hit shader中，instance中被击中的三角形的id(对三角形网格来说) </p>
</li>
<li><p><code>gl_ObjectToWorldEXT : Mat4x4</code> 在closest hit shader中， instance从object空间到world空间的变换矩阵</p>
</li>
<li><p><code>gl_WorldToObjectEXT : Mat4x4</code>在closest hit shader中，instance从world空间到object空间的变换据矩阵</p>
</li>
<li><p><code>gl_WorldRayOriginEXT : vec3</code> 在closest hit shader中，击中该点的ray的世界坐标</p>
</li>
<li><p><code>gl_WorldRayDirectionEXT : vec3</code> 在closest hit shader中，击中该点的ray的世界方向</p>
</li>
<li><p><code>gl_HitTEXT : float</code> 在closest hit shader中，击中该点的ray的t值</p>
</li>
<li><p><code>hitAttributeEXT</code> 修饰符，修饰存储了ray和instance相交点的信息。被修饰的变量只能在instance shader中写入，在closest hit shader和any hit shader中读取。在instance shader缺省，与三角形网格求交的过程中，会有一个<code>hitAttributeEXT vec2 uv</code>传入closest hit和any hit shader。通过它可以获取当前相交点的uv值。(<a target="_blank" rel="noopener" href="https://github.com/KhronosGroup/SPIRV-Registry/blob/main/extensions/KHR/SPV_KHR_ray_tracing.asciidoc">https://github.com/KhronosGroup/SPIRV-Registry/blob/main/extensions/KHR/SPV_KHR_ray_tracing.asciidoc</a> 5339部分)例如：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a closest hit shader</span></span><br><span class="line"><span class="meta">#extension GL_EXT_ray_tracing : require</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">hitAttributeEXT <span class="type">vec2</span> localUv;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">	<span class="type">vec2</span> uv0,uv1,uv2;</span><br><span class="line">	<span class="type">vec2</span> uv = uv0 * (<span class="number">1.0</span> - localUv.x -localUv.y) + uv1 * localUv.x + uv2 * localUv.y;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">tzn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/12/05/vkrt/">http://example.com/2023/12/05/vkrt/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">tzn的小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/vulkan/">vulkan</a></div><div class="post_share"><div class="social-share" data-image="/images/miku0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/12/05/debugPrintfExt/" title="如何在glsl中使用printf--debugPrintfExt"><img class="cover" src="/images/otto0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">如何在glsl中使用printf--debugPrintfExt</div></div></a></div><div class="next-post pull-right"><a href="/2023/12/05/Smoothed-particle-hydrodynamics/" title="Smoothed-particle hydrodynamics"><img class="cover" src="/images/ia0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Smoothed-particle hydrodynamics</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/12/05/debugPrintfExt/" title="如何在glsl中使用printf--debugPrintfExt"><img class="cover" src="/images/otto0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-05</div><div class="title">如何在glsl中使用printf--debugPrintfExt</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/ranran0.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">tzn</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/tzn893"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">tzn的笔记杂物间, 以后可能会写点有杂谈发电在这里捏</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%87%86%E5%A4%87%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">1.准备部分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8A%A0%E9%80%9F%E7%BB%93%E6%9E%84acceleration-structure"><span class="toc-number">2.</span> <span class="toc-text">2.加速结构acceleration structure</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-Bottom-Level-Acceleration-Structure"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Bottom Level Acceleration Structure</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-1-Build-Bottom-Level-Acceleration-Structure"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 Build Bottom Level Acceleration Structure</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-1-2-Build-Compacted-Bottom-Level-Acceleration-Structure"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 Build Compacted Bottom Level Acceleration Structure</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-Build-Top-Level-Acceleration-Structure"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 Build Top Level Acceleration Structure</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Ray-Tracing-Pipeline"><span class="toc-number">3.</span> <span class="toc-text">3.Ray Tracing Pipeline</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-Create-Ray-Tracing-Pipeline-and-Shader-Binding-Table"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 Create Ray Tracing Pipeline and Shader Binding Table</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-Ray-Trace-Command"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 Ray Trace Command</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Ray-Tracing-GLSL"><span class="toc-number">4.</span> <span class="toc-text">4.Ray Tracing GLSL</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/07/pbd01/" title="Position Based Dynamic (一)"><img src="/images/miku1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Position Based Dynamic (一)"/></a><div class="content"><a class="title" href="/2024/06/07/pbd01/" title="Position Based Dynamic (一)">Position Based Dynamic (一)</a><time datetime="2024-06-07T02:20:31.000Z" title="发表于 2024-06-07 10:20:31">2024-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/03/NewtonJsonUnity/" title="Unity中的Newtonsoft.Json---(1)"><img src="/images/mika0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Unity中的Newtonsoft.Json---(1)"/></a><div class="content"><a class="title" href="/2024/01/03/NewtonJsonUnity/" title="Unity中的Newtonsoft.Json---(1)">Unity中的Newtonsoft.Json---(1)</a><time datetime="2024-01-03T03:06:14.000Z" title="发表于 2024-01-03 11:06:14">2024-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/07/mpm01/" title="物质质点法--从理论到实现"><img src="/images/16801.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="物质质点法--从理论到实现"/></a><div class="content"><a class="title" href="/2023/12/07/mpm01/" title="物质质点法--从理论到实现">物质质点法--从理论到实现</a><time datetime="2023-12-06T16:44:02.000Z" title="发表于 2023-12-07 00:44:02">2023-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/debugPrintfExt/" title="如何在glsl中使用printf--debugPrintfExt"><img src="/images/otto0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何在glsl中使用printf--debugPrintfExt"/></a><div class="content"><a class="title" href="/2023/12/05/debugPrintfExt/" title="如何在glsl中使用printf--debugPrintfExt">如何在glsl中使用printf--debugPrintfExt</a><time datetime="2023-12-05T07:43:07.000Z" title="发表于 2023-12-05 15:43:07">2023-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/05/vkrt/" title="vulkan 光线追踪"><img src="/images/miku0.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="vulkan 光线追踪"/></a><div class="content"><a class="title" href="/2023/12/05/vkrt/" title="vulkan 光线追踪">vulkan 光线追踪</a><time datetime="2023-12-05T07:40:26.000Z" title="发表于 2023-12-05 15:40:26">2023-12-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By tzn</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>